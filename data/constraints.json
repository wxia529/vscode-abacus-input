{
  "abs_broadening (Under Development Feature)": {
    "availability": "",
    "default": "0.01",
    "description": "The broadening factor $\\eta$ for the absorption spectrum calculation.",
    "mdType": "Real",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "number",
    "unit": ""
  },
  "abs_wavelen_range (Under Development Feature)": {
    "availability": "",
    "default": "0.0 0.0",
    "description": "The range of the wavelength for the absorption spectrum calculation.",
    "mdType": "Real Real",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "aims_nbasis (Under Development Feature)": {
    "availability": "`ri_hartree_benchmark` = `aims`",
    "default": "{} (empty list, where ABACUS use its own basis set size)",
    "description": "Atomic basis set size for each atom type (with the same order as in `STRU`) in FHI-aims.",
    "mdType": "A number(ntype) of Integers",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "basis_type": {
    "availability": "",
    "default": "pw",
    "description": "Choose the basis set.\n  - pw: Using plane-wave basis set only.\n  - lcao: Using localized atomic orbital sets.\n  - lcao_in_pw: Expand the localized atomic set in plane-wave basis, non-self-consistent field calculation not tested.",
    "enum": [
      "pw",
      "lcao",
      "lcao_in_pw"
    ],
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "berry_phase": {
    "availability": "",
    "default": "false",
    "description": "Controls the calculation of Berry phase\n  - true: Calculate Berry phase.\n  - false: Do not calculate Berry phase.",
    "mdType": "Boolean",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "bessel_descriptor_ecut": {
    "availability": "`gen_bessel` calculation",
    "default": "same as ecutwfc",
    "description": "energy cutoff of Bessel functions",
    "mdType": "Real",
    "section": "DeePKS",
    "type": "number",
    "unit": "Ry"
  },
  "bessel_descriptor_lmax": {
    "availability": "`gen_bessel` calculation",
    "default": "2",
    "description": "the maximum angular momentum of the Bessel functions generated as the projectors in DeePKS",
    "mdType": "Integer",
    "section": "DeePKS",
    "type": "integer",
    "unit": ""
  },
  "bessel_descriptor_rcut": {
    "availability": "`gen_bessel` calculation",
    "default": "6.0",
    "description": "cutoff radius of Bessel functions",
    "mdType": "Real",
    "section": "DeePKS",
    "type": "number",
    "unit": "Bohr"
  },
  "bessel_descriptor_sigma": {
    "availability": "`gen_bessel` calculation",
    "default": "0.1",
    "description": "smooth parameter at the cutoff radius of projectors",
    "mdType": "Real",
    "section": "DeePKS",
    "type": "number",
    "unit": "Bohr"
  },
  "bessel_descriptor_smooth": {
    "availability": "`gen_bessel` calculation",
    "default": "False",
    "description": "smooth the Bessel functions at radius cutoff",
    "mdType": "Boolean",
    "section": "DeePKS",
    "type": "boolean",
    "unit": ""
  },
  "bessel_descriptor_tolerence": {
    "availability": "`gen_bessel` calculation",
    "default": "1.0e-12",
    "description": "tolerance for searching the zeros of Bessel functions",
    "mdType": "Real",
    "section": "DeePKS",
    "type": "number",
    "unit": ""
  },
  "bessel_nao_ecut": {
    "availability": "",
    "default": "`ecutwfc`",
    "description": "\"Energy cutoff\" (in Ry) of spherical Bessel functions. The number of spherical Bessel functions that constitute the radial parts of NAOs is determined by sqrt(`bessel_nao_ecut`)$\\times$`bessel_nao_rcut`/$\\pi$.",
    "mdType": "Real",
    "section": "NAOs",
    "type": "number",
    "unit": ""
  },
  "bessel_nao_rcut": {
    "availability": "",
    "default": "6.0",
    "description": "Cutoff radius (in Bohr) and the common node of spherical Bessel functions used to construct the NAOs.",
    "mdType": "Real",
    "section": "NAOs",
    "type": "number",
    "unit": ""
  },
  "bessel_nao_sigma": {
    "availability": "",
    "default": "0.1",
    "description": "Smoothing range (in Bohr). See also `bessel_nao_smooth`.",
    "mdType": "Real",
    "section": "NAOs",
    "type": "number",
    "unit": ""
  },
  "bessel_nao_smooth": {
    "availability": "",
    "default": "True",
    "description": "If True, NAOs will be smoothed near the cutoff radius by $1-\\exp\\left(-\\frac{(r-r_{cut})^2}{2\\sigma^2}\\right)$. See `bessel_nao_rcut` for $r_{cut}$ and `bessel_nao_sigma` for $\\sigma$.",
    "mdType": "Boolean",
    "section": "NAOs",
    "type": "boolean",
    "unit": ""
  },
  "bessel_nao_tolerence": {
    "availability": "",
    "default": "1.0e-12",
    "description": "Tolerance when searching for the zeros of spherical Bessel functions.",
    "mdType": "Real",
    "section": "NAOs",
    "type": "number",
    "unit": ""
  },
  "block": {
    "availability": "",
    "default": "false",
    "description": "Controls the addition of a potential barrier to prevent electron spillover.\n  - true: A potential barrier is added from **block_down** to **block_up** with a height of **block_height**. If **dip_cor_flag** is set to true, **efield_pos_dec** is used to smoothly increase and decrease the potential barrier.\n  - false: No potential barrier is added.",
    "mdType": "Boolean",
    "section": "Gate field (compensating charge)",
    "type": "boolean",
    "unit": ""
  },
  "block_down": {
    "availability": "",
    "default": "0.45",
    "description": "Lower beginning of the potential barrier",
    "mdType": "Real",
    "section": "Gate field (compensating charge)",
    "type": "number",
    "unit": "Unit cell size"
  },
  "block_height": {
    "availability": "",
    "default": "0.1",
    "description": "Height of the potential barrier",
    "mdType": "Real",
    "section": "Gate field (compensating charge)",
    "type": "number",
    "unit": "Rydberg"
  },
  "block_up": {
    "availability": "",
    "default": "0.55",
    "description": "Upper beginning of the potential barrier",
    "mdType": "Real",
    "section": "Gate field (compensating charge)",
    "type": "number",
    "unit": "Unit cell size"
  },
  "bndpar": {
    "availability": "",
    "default": "1",
    "description": "Divide all processors into bndpar groups, and bands (only stochastic orbitals now) will be distributed among each group. It should be larger than 0.",
    "exclusiveMinimum": 0.0,
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "bx": {
    "availability": "",
    "default": "0",
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values.",
    "mdType": "Integer",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "by": {
    "availability": "",
    "default": "0",
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values.",
    "mdType": "Integer",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "bz": {
    "availability": "",
    "default": "0",
    "description": "In the matrix operation of grid integral, bx/by/bz grids (in x, y, z directions) are treated as a whole as a matrix element. A different value will affect the calculation speed. The default is 0, which means abacus will automatically calculate these values.",
    "mdType": "Integer",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "cal_cond": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "False",
    "description": "Whether to calculate electronic conductivities.",
    "mdType": "Boolean",
    "section": "Electronic conductivities",
    "type": "boolean",
    "unit": ""
  },
  "cal_force": {
    "availability": "",
    "default": "False if `calculation` is set to `scf`, True if `calculation` is set to `cell-relax`, `relax`, or `md`.",
    "description": "- **True**: Calculate the force at the end of the electronic iteration\n  - **False**: No force calculation at the end of the electronic iteration\n\n**Default**: False if `calculation` is set to `scf`, True if `calculation` is set to `cell-relax`, `relax`, or `md`.",
    "mdType": "Boolean",
    "section": "Geometry relaxation",
    "type": "boolean",
    "unit": ""
  },
  "cal_stress": {
    "availability": "",
    "default": "True if `calculation` is `cell-relax`, False otherwise.",
    "description": "- **True**: Calculate the stress at the end of the electronic iteration\n  - **False**: No calculation of the stress at the end of the electronic iteration\n\n**Default**: True if `calculation` is `cell-relax`, False otherwise.",
    "mdType": "Boolean",
    "section": "Geometry relaxation",
    "type": "boolean",
    "unit": ""
  },
  "cal_symm_repr": {
    "availability": "",
    "default": "1 3",
    "description": "Whether to print the matrix representation of symmetry operation to running log file. If the first value is given as 1, then all matrix representations will be printed. The second optional parameter controls the precision (number of digits) to print, default is 3, which is enough for a quick check.",
    "mdType": "Integer [Integer]\\(optional\\)",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "cal_syns": {
    "availability": "",
    "default": "False",
    "description": "Whether to calculate and output asynchronous overlap matrix for Hefei-NAMD interface. When enabled, calculates `<phi(t-1)|phi(t)>` by computing overlap between basis functions at atomic positions from previous time step and current time step. The overlap is calculated by shifting atom positions backward by `velocity × md_dt`. Output file: `OUT.*/syns_nao.csr` in CSR format.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "calculation": {
    "availability": "",
    "default": "scf",
    "description": "Specify the type of calculation.\n\n  - scf: perform self-consistent electronic structure calculations\n  - nscf: perform non-self-consistent electronic structure calculations. A charge density file is required\n  - relax: perform structure relaxation calculations, the `relax_nmax` parameter depicts the maximal number of ionic iterations\n  - cell-relax: perform cell relaxation calculations\n  - md: perform molecular dynamics simulations\n  - get_pchg: obtain partial (band-decomposed) charge densities (for LCAO basis only). See `out_pchg` for more information\n  - get_wf: obtain real space wave functions (for LCAO basis only). See `out_wfc_norm` and `out_wfc_re_im` for more information\n  - get_s: obtain the overlap matrix formed by localized orbitals (for LCAO basis with multiple k points). the file name is `SR.csr` with file format being the same as that generated by [out_mat_hs2](#out_mat_hs2). Note: in the 3.10-LTS version, the command was named `get_S`\n  - gen_bessel: generates projectors, i.e., a series of Bessel functions, for the DeePKS method (for LCAO basis only); see also keywords `bessel_descriptor_lmax`, `bessel_descriptor_rcut` and `bessel_descriptor_tolerence`. A file named `jle.orb` will be generated which contains the projectors. An example is provided in examples/H2O-deepks-pw\n  - gen_opt_abfs: generate opt-ABFs as discussed in this [article](https://pubs.acs.org/doi/abs/10.1021/acs.jpclett.0c00481).\n  - test_memory: obtain a rough estimation of memory consuption for the calculation\n  - test_neighbour: obtain information of neighboring atoms (for LCAO basis only), please specify a positive [search_radius](#search_radius) manually",
    "enum": [
      "scf",
      "nscf",
      "relax",
      "cell-relax",
      "md",
      "get_pchg",
      "get_wf",
      "get_s",
      "gen_bessel",
      "gen_opt_abfs",
      "test_memory",
      "test_neighbour"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "cell_factor": {
    "availability": "",
    "default": "1.2",
    "description": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": ""
  },
  "chg_extrap": {
    "availability": "",
    "default": "first-order (geometry relaxations), second-order (molecular dynamics), else atomic",
    "description": "Methods to do extrapolation of density when ABACUS is doing geometry relaxations or molecular dynamics.\n  - atomic: atomic extrapolation.\n  - first-order: first-order extrapolation.\n  - second-order: second-order extrapolation.",
    "enum": [
      "atomic",
      "first-order",
      "second-order"
    ],
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "cond_che_thr": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "1e-8",
    "description": "Control the error of Chebyshev expansions for conductivities.",
    "mdType": "Real",
    "section": "Electronic conductivities",
    "type": "number",
    "unit": ""
  },
  "cond_dt": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "0.02",
    "description": "Time interval ($\\mathrm{d}t$) to integrate Onsager coefficients.",
    "mdType": "Real",
    "section": "Electronic conductivities",
    "type": "number",
    "unit": "a.u."
  },
  "cond_dtbatch": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0",
    "description": "exp(iH\\*dt\\*cond_dtbatch) is expanded with Chebyshev expansion to calculate conductivities. It is faster but costs more memory.\n  - If `cond_dtbatch = 0`: Autoset this parameter to make expansion orders larger than 100.",
    "exclusiveMinimum": 100.0,
    "mdType": "Integer",
    "section": "Electronic conductivities",
    "type": "integer",
    "unit": ""
  },
  "cond_dw": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "0.1",
    "description": "Frequency interval ($\\mathrm{d}\\omega$) for frequency-dependent conductivities.",
    "mdType": "Real",
    "section": "Electronic conductivities",
    "type": "number",
    "unit": "eV"
  },
  "cond_fwhm": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "0.4",
    "description": "FWHM for conductivities. For Gaussian smearing, $\\mathrm{FWHM}=2\\sqrt{2\\ln2}s$; for Lorentzian smearing, $\\mathrm{FWHM}=2\\gamma$.",
    "mdType": "Real",
    "section": "Electronic conductivities",
    "type": "number",
    "unit": "eV"
  },
  "cond_nonlocal": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "True",
    "description": "Whether to consider nonlocal potential correction when calculating velocity matrix $\\bra{\\psi_i}\\hat{v}\\ket{\\psi_j}$.\n  - True:  $m\\hat{v}=\\hat{p}+\\frac{im}{\\hbar}[\\hat{V}_{NL},\\hat{r}]$.\n  - False: $m\\hat{v}\\approx\\hat{p}$.",
    "mdType": "Boolean",
    "section": "Electronic conductivities",
    "type": "boolean",
    "unit": ""
  },
  "cond_smear": {
    "availability": "",
    "default": "1",
    "description": "Smearing method for conductivities\n  - 1: Gaussian smearing\n  - 2: Lorentzian smearing",
    "enum": [
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Electronic conductivities",
    "type": "integer",
    "unit": ""
  },
  "cond_wcut": {
    "availability": "[basis_type](#basis_type) = `pw`",
    "default": "10.0",
    "description": "Cutoff frequency for frequency-dependent conductivities.",
    "mdType": "Real",
    "section": "Electronic conductivities",
    "type": "number",
    "unit": "eV"
  },
  "deepks_band_range": {
    "availability": "Numerical atomic orbital basis, `deepks_scf` is true, and `deepks_bandgap` is 1 or 2",
    "default": "-1 0",
    "description": "The first value should not be larger than the second one and the meaning differs in different cases below\n  - `deepks_bandgap` is 1: Bandgap label is the energy between `LUMO + deepks_band_range[0]` and `LUMO + deepks_band_range[1]`. If not set, it will calculate energy between HOMO and LUMO states.\n  - `deepks_bandgap` is 2: Bandgap labels are energies between HOMO and all states in range [`LUMO + deepks_band_range[0]`, `LUMO + deepks_band_range[1]`] (Thus there are `deepks_band_range[1] - deepks_band_range[0] + 1` bandgaps in total). If HOMO is included in the setting range, it will be ignored since it will always be zero and has no valuable messages (`deepks_band_range[1] - deepks_band_range[0]` bandgaps in this case). *NOTICE: The set range can be greater than, less than, or include the value of HOMO. In the bandgap label, we always calculate the energy of the state in the set range minus the energy of HOMO state, so the bandgap can be negative if the state is lower than HOMO.*",
    "mdType": "Int*2",
    "section": "DeePKS",
    "type": "string",
    "unit": ""
  },
  "deepks_bandgap": {
    "availability": "Numerical atomic orbital basis and `deepks_scf` is true",
    "default": "0",
    "description": "include bandgap label for DeePKS training\n  - 0: Don't include bandgap label\n  - 1: Include target bandgap label (see [deepks\\_band\\_range](#deepks_band_range) for more details)\n  - 2: Include multiple bandgap label (see [deepks\\_band\\_range](#deepks_band_range) for more details)\n  - 3: Used for systems containing H atoms. Here HOMO is defined as the max occupation except H atoms and the bandgap label is the energy between HOMO and (HOMO + 1)",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "Int",
    "section": "DeePKS",
    "type": "integer",
    "unit": ""
  },
  "deepks_equiv": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "whether to use equivariant version of DeePKS",
    "mdType": "Boolean",
    "section": "DeePKS",
    "type": "boolean",
    "unit": ""
  },
  "deepks_model": {
    "availability": "Numerical atomic orbital basis and `deepks_scf` is true",
    "default": "None",
    "description": "the path of the trained, traced neural network model file generated by [deepks-kit](https://github.com/deepmodeling/deepks-kit)",
    "mdType": "String",
    "section": "DeePKS",
    "type": "string",
    "unit": ""
  },
  "deepks_out_base": {
    "availability": "Numerical atomic orbital basis and `deepks_out_freq_elec` is greater than 0",
    "default": "None",
    "description": "Print labels and descriptors calculated by base functional ( determined by `deepks_out_base` ) and target functional ( determined by `dft_functional` ) for DeePKS in per `deepks_out_freq_elec` electronic iterations. The SCF process, labels and descriptors output of the target functional are all consistent with those when the target functional is used alone. The only additional output under this configuration is the labels of the base functional. Often used with `deepks_out_labels` equals 1.",
    "mdType": "String",
    "section": "DeePKS",
    "type": "string",
    "unit": ""
  },
  "deepks_out_freq_elec": {
    "availability": "Numerical atomic orbital basis",
    "default": "0",
    "description": "When `deepks_out_freq_elec` is greater than 0, print labels and descriptors for DeePKS in OUT.${suffix}/DeePKS_Labels_Elec per `deepks_out_freq_elec` electronic iterations, with suffix `_e*` to distinguish different steps. Often used with `deepks_out_labels` equals 1.",
    "exclusiveMinimum": 0.0,
    "mdType": "Integer",
    "section": "DeePKS",
    "type": "integer",
    "unit": ""
  },
  "deepks_out_labels": {
    "availability": "Numerical atomic orbital basis",
    "default": "0",
    "description": "Print labels and descriptors for DeePKS in OUT.${suffix}. The names of these files start with \"deepks\".\n  - 0 : No output.\n  - 1 : Output intermediate files needed during DeePKS training.\n  - 2 : Output target labels for label preperation. The label files are named as `deepks_<property>.npy` or `deepks_<property>.csr`, where the units and formats are the same as label files `<property>.npy` or `<property>.csr` required for training, except that the first dimension (`nframes`) is excluded. System structrue files are also given in `deepks_atom.npy` and `deepks_box.npy` in the unit of *Bohr*, which means `lattice_constant` should be set to 1 when training.",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "DeePKS",
    "type": "integer",
    "unit": ""
  },
  "deepks_out_unittest": {
    "availability": "",
    "default": "False",
    "description": "generate files for constructing DeePKS unit test",
    "mdType": "Boolean",
    "section": "DeePKS",
    "type": "boolean",
    "unit": ""
  },
  "deepks_scf": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "perform self-consistent field iteration in DeePKS method",
    "mdType": "Boolean",
    "section": "DeePKS",
    "type": "boolean",
    "unit": ""
  },
  "deepks_v_delta": {
    "availability": "Numerical atomic orbital basis",
    "default": "0",
    "dependencies": {
      "deepks_out_labels": true
    },
    "description": "Include V_delta/V_delta_R (Hamiltonian in k/real space) label for DeePKS training. When `deepks_out_labels` is true and `deepks_v_delta` > 0 (k space), ABACUS will output `deepks_hbase.npy`, `deepks_vdelta.npy` and `deepks_htot.npy`(htot=hbase+vdelta). When `deepks_out_labels` is true and `deepks_v_delta` < 0 (real space), ABACUS will output `deepks_hrtot.csr`, `deepks_hrdelta.csr`. Some more files output for different settings. *NOTICE: To match the unit Normally used in DeePKS, the unit of Hamiltonian in k space is Hartree. However, currently in R space the unit is still Ry.*\n  - `deepks_v_delta` = 1: `deepks_vdpre.npy`, which is used to calculate V_delta during DeePKS training.\n  - `deepks_v_delta` = 2: `deepks_phialpha.npy` and `deepks_gevdm.npy`, which can be used to calculate `deepks_vdpre.npy`. A recommanded method for memory saving.\n  - `deepks_v_delta` = -1: `deepks_vdrpre.npy`, which is used to calculate V_delta_R during DeePKS training.\n  - `deepks_v_delta` = -2: `deepks_phialpha_r.npy` and `deepks_gevdm.npy`, which can be used to calculate `deepks_vdrpre.npy`. A recommanded method for memory saving.",
    "mdType": "int",
    "section": "DeePKS",
    "type": "integer",
    "unit": ""
  },
  "device": {
    "availability": "",
    "default": "cpu",
    "description": "Specifies the computing device for ABACUS.\n\n  Available options are:\n\n  - cpu: for CPUs via Intel, AMD, or Other supported CPU devices\n  - gpu: for GPUs via CUDA or ROCm.\n\n  Known limitations: `ks_solver` must also be set to the algorithms supported. lcao_in_pw currently does not support `gpu`.",
    "enum": [
      "cpu",
      "gpu"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "dft_functional": {
    "availability": "",
    "default": "Used the same as DFT functional as specified in the pseudopotential files.",
    "description": "In our package, the XC functional can either be set explicitly using the `dft_functional` keyword in `INPUT` file. If `dft_functional` is not specified, ABACUS will use the xc functional indicated in the pseudopotential file.\n  On the other hand, if dft_functional is specified, it will overwrite the functional from pseudopotentials and performs calculation with whichever functional the user prefers. We further offer two ways of supplying exchange-correlation functional. The first is using 'short-hand' names. A complete list of 'short-hand' expressions can be found in [the source code](../../../source/source_hamilt/module_xc/xc_functional.cpp). Supported density functionals are:\n  - LDA functionals\n    - LDA (equivalent with PZ and SLAPZNOGXNOGC), PWLDA\n  - GGA functionals\n    - PBE (equivalent with SLAPWPBXPBC), PBESOL, REVPBE, WC, BLYP, BP(referred to BP86), PW91, HCTH, OLYP, BLYP_LR\n  - meta-GGA functionals\n    - SCAN (require LIBXC)\n  - Hybrid functionals\n    - PBE0, HF\n    - If LIBXC is avaliale, additional short-hand names of hybrid functionals are supported: HSE(referred to HSE06), B3LYP, LC_PBE, LC_WPBE, LRC_WPBE, LRC_WPBEH, CAM_PBEH, WP22, CWP22, MULLER (equivalent with POWER)\n  - Hybrid meta-GGA functionals\n    - SCAN0 (require LIBXC)\n\n   The other way is only available when ***compiling with LIBXC***, and it allows for supplying exchange-correlation functionals as combinations of LIBXC keywords for functional components, joined by a plus sign, for example, dft_functional='LDA_X_1D_EXPONENTIAL+LDA_C_1D_CSC'. The list of LIBXC keywords can be found on its [website](https://libxc.gitlab.io/functionals/). In this way, **we support all the LDA,GGA and mGGA functionals provided by LIBXC**. Some popular functionals and their usage are: RPBE of [Hammer et al.](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.59.7413), set `dft_functional` to 'GGA_X_RPBE+GGA_C_PBE', and [r$^{2}$SCAN](https://pubs.acs.org/doi/10.1021/acs.jpclett.0c02405), set `dft_functional` to 'MGGA_X_R2SCAN+MGGA_C_R2SCAN'.\n\n  Furthermore, the old INPUT parameter exx_hybrid_type for hybrid functionals has been absorbed into dft_functional. Options are `hf` (pure Hartree-Fock), `pbe0`(PBE0), `hse` (Note: in order to use HSE functional, LIBXC is required). Note also that HSE has been tested while PBE0 has NOT been fully tested yet, and the maximum CPU cores for running exx in parallel is $N(N+1)/2$, with N being the number of atoms.",
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "dft_plus_u": {
    "availability": "",
    "default": "0",
    "description": "Determines whether to calculate the plus U correction, which is especially important for correlated electrons.\n  - 1: Calculate plus U correction with radius-adjustable localized projections (with parameter `onsite_radius`).\n  - 2: Calculate plus U correction using first zeta of NAOs as projections (this is old method for testing).\n  - 0: Do not calculate plus U correction.",
    "enum": [
      "1",
      "2",
      "0"
    ],
    "mdType": "Integer",
    "section": "DFT+*U* correction",
    "type": "integer",
    "unit": ""
  },
  "dfthalf_type": {
    "availability": "Relevant for DFT-1/2 calculations.",
    "default": "0",
    "description": "Choose the type of DFT-1/2 calcutions. Currently, only the PW basis set is supported.\n  - 0: Do not consider DFT-1/2 correction.\n  - 1: Apply DFT-1/2(shell DFT-1/2) correction.\n\n  In addition, the SEP_FILES keyword also needs to be added to the STRU file, followed by the DFT-1/2 settings for each element, listed in the same order as ATOMIC_SPECIES. The format is\n```\nSEP_FILES\nATOM_LABEL is_enable SEP_FILENAME r_in r_out r_power scale.\n```\nFor example,\n```\nSEP_FILES\nLi 0\nF  1 F_pbe_50.sep 0.0 2.2 20.0 1.0\n```\nATOM_LABEL must remain consistent with the definition in ATOMIC_SPECIES. Setting is_enable to 0 indicates that the DFT-1/2 correction will not be applied, while setting it to 1 indicates that the DFT-1/2 correction will be applied. SEP_FILENAME specifies the self-energy potential file used for this element; more self-energy potential files can be downloaded from [SEP files](http://www.eedevice.com/abacus-half.html). The corresponding self-energy potential files should be placed under [pseudo\\_dir](#pseudo_dir), maintaining the same location as the pseudopotential files. r_in denotes the inner cutoff radius, r_out denotes the outer cutoff radius, and r_power determines the transition at the edge of the cutoff function—larger values result in a sharper transition, but may hinder convergence; a value of 20 is a suitable choice. scale is the self-energy potential scaling factor, with a default value of 1.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "int",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "diag_subspace": {
    "availability": "",
    "default": "0",
    "description": "The method to diagonalize subspace in dav_subspace method. The available options are:\n  - 0: by LAPACK\n  - 1: by GenELPA\n  - 2: by ScaLAPACK\n  LAPACK only solve in one core, GenELPA and ScaLAPACK can solve in parallel. If the system is small (such as the band number is less than 100), LAPACK is recommended. If the system is large and MPI parallel is used, then GenELPA or ScaLAPACK is recommended, and GenELPA usually has better performance. For GenELPA and ScaLAPACK, the block size can be set by [nb2d](#nb2d).",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "exclusiveMaximum": 100.0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "diago_proc": {
    "availability": "Used only for plane wave basis set.",
    "default": "0",
    "description": "- 0: it will be set to the number of MPI processes. Normally, it is fine just leave it to the default value.\n  - `>0`: it specifies the number of processes used for carrying out diagonalization. Must be less than or equal to total number of MPI processes. Also, when cg diagonalization is used, diago_proc must be the same as the total number of MPI processes.",
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "diago_smooth_ethr": {
    "availability": "",
    "default": "false",
    "description": "If `TRUE`, the smooth threshold strategy, which applies a larger threshold (10e-5) for the empty states, will be implemented in the diagonalization methods. (This strategy should not affect total energy, forces, and other ground-state properties, but computational efficiency will be improved.) If `FALSE`, the smooth threshold strategy will not be applied.",
    "mdType": "bool",
    "section": "Plane wave related variables",
    "type": "boolean",
    "unit": ""
  },
  "dip_cor_flag": {
    "availability": "With dip_cor_flag = True and efield_flag = True.",
    "default": "False",
    "description": "Added a dipole correction to the bare ionic potential.\n  - True：A dipole correction is also added to the bare ionic potential.\n  - False: A dipole correction is not added to the bare ionic potential.\n\n> Note: If you do not want any electric field, the parameter `efield_amp` should be set to zero. This should ONLY be used in a slab geometry for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE.",
    "mdType": "Boolean",
    "section": "Electric field and dipole correction",
    "type": "boolean",
    "unit": ""
  },
  "dm_to_rho (Under Development Feature)": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Reads density matrix $DM(R)$ in npz format and creates electron density on grids. This feature does not work for gamma-only calculations. Only supports serial calculations.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "dmax": {
    "availability": "",
    "default": "0.01",
    "description": "The maximum displacement of all atoms in one step. This parameter is useful when [cal_syns](#cal_syns) = True.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "bohr"
  },
  "dos_edelta_ev": {
    "availability": "",
    "default": "0.01",
    "description": "The step size in writing Density of States (DOS)",
    "mdType": "Real",
    "section": "Density of states",
    "type": "number",
    "unit": "eV"
  },
  "dos_emax_ev": {
    "availability": "",
    "default": "Maximal eigenenergy of $\\hat{H}$",
    "description": "The maximal range for Density of States (DOS)\n  - If set, \"dos_scale\" will be ignored.",
    "mdType": "Real",
    "section": "Density of states",
    "type": "number",
    "unit": "eV"
  },
  "dos_emin_ev": {
    "availability": "",
    "default": "Minimal eigenenergy of $\\hat{H}$",
    "description": "The minimal range for Density of States (DOS)\n  - If set, \"dos_scale\" will be ignored.",
    "mdType": "Real",
    "section": "Density of states",
    "type": "number",
    "unit": "eV"
  },
  "dos_nche": {
    "availability": "",
    "default": "100",
    "description": "The order of Chebyshev expansions when using Stochastic Density Functional Theory (SDFT) to calculate DOS.",
    "mdType": "Integer",
    "section": "Density of states",
    "type": "integer",
    "unit": ""
  },
  "dos_scale": {
    "availability": "",
    "default": "0.01",
    "description": "Defines the energy range of DOS output as (emax-emin)*(1+dos_scale), centered at (emax+emin)/2. This parameter will be used when dos_emin and dos_emax are not set.",
    "mdType": "Real",
    "section": "Density of states",
    "type": "number",
    "unit": "eV"
  },
  "dos_sigma": {
    "availability": "",
    "default": "0.07",
    "description": "The width of the Gaussian factor when obtaining smeared Density of States (DOS)",
    "mdType": "Real",
    "section": "Density of states",
    "type": "number",
    "unit": "eV"
  },
  "dp_aparam": {
    "availability": "[esolver_type](#esolver_type) = `dp`.",
    "default": "{}",
    "description": "The atomic parameter for dp potential. The array size can be (1) natoms x dim_aparam, then all frames are assumed to be provided with the same aparam; (2) dim_aparam, then all frames and atoms are assumed to be provided with the same aparam.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": ""
  },
  "dp_fparam": {
    "availability": "[esolver_type](#esolver_type) = `dp`.",
    "default": "{}",
    "description": "The frame parameter for dp potential. The array size is dim_fparam, then all frames are assumed to be provided with the same fparam.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": ""
  },
  "dp_rescaling": {
    "availability": "[esolver_type](#esolver_type) = `dp`.",
    "default": "1.0",
    "description": "Rescaling factor to use a temperature-dependent DP. Energy, stress and force calculated by DP will be multiplied by this factor.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": ""
  },
  "dump_force": {
    "availability": "",
    "default": "True",
    "description": "Whether to output atomic forces into the file `OUT.${suffix}/MD_dump`.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "dump_vel": {
    "availability": "",
    "default": "True",
    "description": "Whether to output atomic velocities into the file `OUT.${suffix}/MD_dump`.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "dump_virial": {
    "availability": "",
    "default": "True",
    "description": "Whether to output lattice virials into the file `OUT.${suffix}/MD_dump`.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "eb_k": {
    "availability": "`imp_sol` is true.",
    "default": "80",
    "description": "The relative permittivity of the bulk solvent, 80 for water",
    "mdType": "Real",
    "section": "Implicit solvation model",
    "type": "number",
    "unit": ""
  },
  "ecutexx": {
    "availability": "",
    "default": "same as *[ecutrho](#ecutrho)*",
    "description": "The energy cutoff for EXX (Fock) exchange operator in plane wave basis calculations. Reducing `ecutexx` below `ecutrho` may significantly accelerate EXX computations. This speed improvement comes with a reduced numerical accuracy in the exchange energy calculation.",
    "mdType": "Real",
    "section": "Exact Exchange (PW)",
    "type": "number",
    "unit": "Ry"
  },
  "ecutrho": {
    "availability": "",
    "default": "4*ecutwfc",
    "description": "Energy cutoff for charge density and potential. For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. For ultrasoft pseudopotential a larger value than the default is often desirable (`ecutrho` = 8 to 12 times `ecutwfc`, typically). The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an higher values of `ecutrho` to be accurately converged.",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": "Ry"
  },
  "ecutwfc": {
    "availability": "",
    "default": "50 for PW basis, 100 for LCAO basis",
    "description": "Energy cutoff for plane wave functions. Note that even for localized orbitals basis, you still need to setup an energy cutoff for this system. Because our local pseudopotential parts and the related force are calculated from plane wave basis set, etc. Also, because our orbitals are generated by matching localized orbitals to a chosen set of wave functions from a certain energy cutoff, this set of localize orbitals is most accurate under this same plane wave energy cutoff.\n> `ecutwfc` and `ecutrho` can be set simultaneously. Besides, if only one parameter is set, abacus will automatically set another parameter based on the 4-time relationship. If both parameters are not set, the default values will be employed.",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": "Ry"
  },
  "efield_amp": {
    "availability": "with efield_flag = True.",
    "default": "0.0",
    "description": "Amplitude of the electric field. The saw-like potential increases with slope efield_amp  in the region from  efield_pos_max+efield_pos_dec-1) to (efield_pos_max), then decreases until (efield_pos_max+efield_pos_dec), in units of the crystal vector efield_dir.\n\n> Note: The change of slope of this potential must be located in the empty region, or else unphysical forces will result.",
    "mdType": "Real",
    "section": "Electric field and dipole correction",
    "type": "number",
    "unit": "a.u., 1 a.u. = 51.4220632*10^10 V/m."
  },
  "efield_dir": {
    "availability": "with efield_flag = True.",
    "default": "2",
    "description": "The direction of the electric field or dipole correction is parallel to the reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points, efield_dir can set to 0, 1 or 2.\n  - 0: parallel to $b_1=\\frac{2\\pi(a_2\\times a_3)}{a_1\\cdot(a_2\\times a_3)}$\n  - 1: parallel to $b_2=\\frac{2\\pi(a_3\\times a_1)}{a_1\\cdot(a_2\\times a_3)}$\n  - 2: parallel to $b_3=\\frac{2\\pi(a_1\\times a_2)}{a_1\\cdot(a_2\\times a_3)}$",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Electric field and dipole correction",
    "type": "integer",
    "unit": ""
  },
  "efield_flag": {
    "availability": "",
    "default": "False",
    "description": "Added the electric field.\n  - True: A saw-like potential simulating an electric field is added to the bare ionic potential.\n  - False: Not added the electric field.",
    "mdType": "Boolean",
    "section": "Electric field and dipole correction",
    "type": "boolean",
    "unit": ""
  },
  "efield_pos_dec": {
    "availability": "with efield_flag = True.",
    "default": "Autoset to `width of vacuum / 10`",
    "description": "Zone in the unit cell where the saw-like potential decreases, 0 < efield_pos_dec < 1.",
    "mdType": "Real",
    "section": "Electric field and dipole correction",
    "type": "number",
    "unit": ""
  },
  "efield_pos_max": {
    "availability": "with efield_flag = True.",
    "default": "Autoset to `center of vacuum - width of vacuum / 20`",
    "description": "Position of the maximum of the saw-like potential along crystal axis efield_dir, within the  unit cell, 0 <= efield_pos_max < 1.",
    "mdType": "Real",
    "section": "Electric field and dipole correction",
    "type": "number",
    "unit": ""
  },
  "elpa_num_thread": {
    "availability": "",
    "default": "-1",
    "description": "Number of threads used in one elpa calculation.\n\n  If the number is below 0 or 0 or beyond the max number of threads, all elpa calculation will be using all mpi threads",
    "mdType": "int",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "emax_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0.0",
    "description": "Trial energy to guess the upper bound of eigen energies of the Hamiltonian Operator $\\hat{H}$.",
    "mdType": "Real",
    "section": "Electronic structure (SDFT)",
    "type": "number",
    "unit": "Ry"
  },
  "emin_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0.0",
    "description": "Trial energy to guess the lower bound of eigen energies of the Hamiltonian Operator $\\hat{H}$.",
    "mdType": "Real",
    "section": "Electronic structure (SDFT)",
    "type": "number",
    "unit": "Ry"
  },
  "erf_ecut": {
    "availability": "",
    "default": "0.0",
    "description": "Used in variable-cell molecular dynamics (or in stress calculation). See [erf_sigma](#erf_sigma) in detail.",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": "Ry"
  },
  "erf_height": {
    "availability": "",
    "default": "0.0",
    "description": "Used in variable-cell molecular dynamics (or in stress calculation). See [erf_sigma](#erf_sigma) in detail.",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": "Ry"
  },
  "erf_sigma": {
    "availability": "",
    "default": "0.1",
    "description": "In order to recover the accuracy of a constant energy cutoff calculation, the kinetic functional is modified, which is used in variable-cell molecular dynamics (or in stress calculation).\n\n  [erf_ecut](#erf_ecut) is the value of the constant energy cutoff; [erf_height](#erf_height) and [erf_sigma](#erf_sigma) are the height and the width of the energy step for reciprocal vectors whose square modulus is greater than [erf_ecut](#erf_ecut). In the kinetic energy, G^2 is replaced by G^2 + erf_height * (1 + erf ( (G^2 - erf_ecut)/erf_sigma) )\n\n  See: M. Bernasconi et al., J. Phys. Chem. Solids **56**, 501 (1995), [doi:10.1016/0022-3697(94)00228-2](#https://doi.org/10.1016/0022-3697(94)00228-2)",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": "Ry"
  },
  "esolver_type": {
    "availability": "",
    "default": "ksdft",
    "description": "choose the energy solver.\n  - ksdft: Kohn-Sham density functional theory\n  - ofdft: orbital-free density functional theory\n  - tdofdft: time-dependent orbital-free density functional theory\n  - sdft: [stochastic density functional theory](#electronic-structure-sdft)\n  - tddft: real-time time-dependent density functional theory (RT-TDDFT)\n  - lj: Leonard Jones potential\n  - dp: DeeP potential, see details in [md.md](../md.md#dpmd)\n  - nep: Neuroevolution Potential, see details in [md.md](../md.md#nep)\n  - ks-lr: Kohn-Sham density functional theory + LR-TDDFT (Under Development Feature)\n  - lr: LR-TDDFT with given KS orbitals (Under Development Feature)",
    "enum": [
      "ksdft",
      "ofdft",
      "tdofdft",
      "sdft",
      "tddft",
      "lj",
      "dp",
      "nep",
      "ks-lr",
      "lr"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "estep_per_md": {
    "availability": "",
    "default": "1",
    "description": "The number of electronic propagation steps between two ionic steps.",
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "exx_c_grad_r_threshold": {
    "availability": "",
    "default": "1E-4",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). $\\nabla C^{a}_{ik} * R_{ik}$ is used in stress. Smaller components (less than exx_c_grad_r_threshold) of the $\\nabla C^{a}_{ik} * R_{ik}$ matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_c_grad_threshold": {
    "availability": "",
    "default": "1E-4",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). $\\nabla C^{a}_{ik}$ is used in force. Smaller components (less than exx_c_grad_threshold) of the $\\nabla C^{a}_{ik}$ matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_c_threshold": {
    "availability": "",
    "default": "1E-4",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). Smaller components (less than exx_c_threshold) of the $C^{a}_{ik}$ matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_ccp_rmesh_times": {
    "availability": "",
    "default": "- 5: if *[dft_functional](#dft_functional)==hf/pbe0/scan0/muller/power/wp22*\n  - 1.5: if *[dft_functional](#dft_functional)==hse/cwp22*\n  - 1: else",
    "description": "This parameter determines how many times larger the radial mesh required for calculating Columb potential is to that of atomic orbitals. The value should be larger than 0. Reducing this value can effectively increase the speed of self-consistent calculations using hybrid functionals.",
    "exclusiveMinimum": 0.0,
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_ccp_threshold": {
    "availability": "",
    "default": "1e-8",
    "description": "It is related to the cutoff of on-site Coulomb potentials. (Currently not used)",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_cs_inv_thr": {
    "availability": "",
    "default": "-1",
    "description": "By default, the Coulomb matrix inversion required for obtaining LRI coefficients is performed using LU decomposition. However, this approach may suffer from numerical instabilities when a large set of auxiliary basis functions (ABFs) is employed. When `exx_cs_inv_thr > 0`, the inversion is instead carried out via matrix diagonalization. Eigenvalues smaller than `exx_cs_inv_thr` are discarded to improve numerical stability. A relatively safe and commonly recommended value is `1e-5`.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_dm_threshold": {
    "availability": "",
    "default": "1E-4",
    "description": "The Fock exchange can be expressed as $\\sum_{k,l}(ik|jl)D_{kl}$ where D is the density matrix. Smaller values of the density matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_ene_thr": {
    "availability": "*[exx_thr_type](#exx_thr_type)*==`energy`",
    "default": "1e-5",
    "description": "The threshold for the change of exact exchange energy to judge convergence of the outer loop in the separate loop EXX calculation.",
    "mdType": "Real",
    "section": "Exact Exchange (PW)",
    "type": "number",
    "unit": "Ry"
  },
  "exx_erfc_alpha": {
    "availability": "",
    "default": "see [hybrid_func_params](#hybrid_func_params)",
    "description": "Fraction of short-ranged Fock exchange erfc(wr)/r ($\\beta$) in range-separated hybrid funtionals, so that $E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}$.",
    "mdType": "Real \\[Real...\\](optional)",
    "section": "Exact Exchange (Common)",
    "type": "string",
    "unit": ""
  },
  "exx_erfc_omega": {
    "availability": "",
    "default": "see [hybrid_func_params](#hybrid_func_params)",
    "description": "Range-separation parameter in exchange, such that $1/r=\\text{erfc}(\\omega r)/r+\\text{erf}(\\omega r)/r$",
    "mdType": "Real \\[Real...\\](optional)",
    "section": "Exact Exchange (Common)",
    "type": "string",
    "unit": ""
  },
  "exx_fock_alpha": {
    "availability": "",
    "default": "see [hybrid_func_params](#hybrid_func_params)",
    "description": "Fraction of full-ranged Fock exchange 1/r ($\\alpha$) in range-separated hybrid funtionals, so that $E_{X} = \\alpha E_{X}^\\text{HF-LR}+(\\alpha+\\beta) E_{X}^\\text{HF-SR}+(1-\\alpha)E_{X}^\\text{KS-LR}+[1-(\\alpha+\\beta)]E_{X}^\\text{KS-SR}$.",
    "mdType": "Real \\[Real...\\](optional)",
    "section": "Exact Exchange (Common)",
    "type": "string",
    "unit": ""
  },
  "exx_fock_lambda": {
    "availability": "*[basis_type](#basis_type)==lcao_in_pw*",
    "default": "0.3",
    "description": "It is used to compensate for divergence points at G=0 in the evaluation of Fock exchange using *lcao_in_pw* method.",
    "mdType": "Real \\[Real...\\](optional)",
    "section": "Exact Exchange (LCAO in PW)",
    "type": "string",
    "unit": ""
  },
  "exx_gamma_extrapolation": {
    "availability": "",
    "default": "True",
    "description": "Whether to use the gamma point extrapolation method to calculate the Fock exchange operator. See [https://doi.org/10.1103/PhysRevB.79.205114](https://doi.org/10.1103/PhysRevB.79.205114) for details. Should be set to true most of the time.",
    "mdType": "Boolean",
    "section": "Exact Exchange (PW)",
    "type": "boolean",
    "unit": ""
  },
  "exx_hybrid_step": {
    "availability": "*[exx_separate_loop](#exx_separate_loop)==1*",
    "default": "100",
    "description": "The maximal iteration number of the outer-loop, where the Fock exchange is calculated",
    "mdType": "Integer",
    "section": "Exact Exchange (Common)",
    "type": "integer",
    "unit": ""
  },
  "exx_mixing_beta": {
    "availability": "*[exx_separate_loop](#exx_separate_loop)==1*",
    "default": "1.0",
    "description": "Mixing parameter for densty matrix in each iteration of the outer-loop",
    "mdType": "Real",
    "section": "Exact Exchange (Common)",
    "type": "number",
    "unit": ""
  },
  "exx_opt_orb_ecut": {
    "availability": "*[calculation](#calculation)==gen_opt_abfs*",
    "default": "0",
    "description": "The cut-off of plane wave expansion, when the plane wave basis is used to optimize the radial ABFs. A reasonable choice is 60.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": "Ry"
  },
  "exx_opt_orb_lmax": {
    "availability": "*[calculation](#calculation)==gen_opt_abfs*",
    "default": "0",
    "description": "The maximum l of the spherical Bessel functions, when the radial part of opt-ABFs are generated as linear combinations of spherical Bessel functions. A reasonable choice is 2.",
    "mdType": "Integer",
    "section": "Exact Exchange (LCAO)",
    "type": "integer",
    "unit": ""
  },
  "exx_opt_orb_tolerence": {
    "availability": "*[calculation](#calculation)==gen_opt_abfs*",
    "default": "1E-12",
    "description": "The threshold when solving for the zeros of spherical Bessel functions. A reasonable choice is 1e-12.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_pca_threshold": {
    "availability": "",
    "default": "1E-4",
    "description": "To accelerate the evaluation of four-center integrals ($ik|jl$), the product of atomic orbitals are expanded in the basis of auxiliary basis functions (ABF): $\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}$. The size of the ABF (i.e. number of $P_{a}$) is reduced using principal component analysis. When a large PCA threshold is used, the number of ABF will be reduced, hence the calculation becomes faster. However, this comes at the cost of computational accuracy. A relatively safe choice of the value is 1e-4.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_real_number": {
    "availability": "",
    "default": "depends on the [gamma_only](#gamma_only) option\n  - True: if gamma_only\n  - False: else",
    "description": "- True: Enforce LibRI to use `double` data type.\n  - False: Enforce LibRI to use `complex` data type.\n  Setting it to True can effectively improve the speed of self-consistent calculations with hybrid functionals.",
    "mdType": "Boolean",
    "section": "Exact Exchange (LCAO)",
    "type": "boolean",
    "unit": ""
  },
  "exx_separate_loop": {
    "availability": "",
    "default": "True",
    "description": "There are two types of iterative approaches provided by ABACUS to evaluate Fock exchange.\n  - False: Start with a GGA-Loop, and then Hybrid-Loop, in which EXX Hamiltonian $H_{exx}$ is updated with electronic iterations.\n  - True: A two-step method is employed, i.e. in the inner iterations, density matrix is updated, while in the outer iterations, $H_{exx}$ is calculated based on density matrix that converges in the inner iteration.",
    "mdType": "Boolean",
    "section": "Exact Exchange (Common)",
    "type": "boolean",
    "unit": ""
  },
  "exx_singularity_correction": {
    "availability": "",
    "default": "default",
    "description": "- spencer: see Phys. Rev. B 77, 193110 (2008).\n  - revised_spencer: see Phys. Rev. Mater. 5, 013807 (2021).\n  Set the scheme of Coulomb singularity correction.",
    "enum": [
      "spencer",
      "revised_spencer"
    ],
    "mdType": "String",
    "section": "Exact Exchange (LCAO)",
    "type": "string",
    "unit": ""
  },
  "exx_symmetry_realspace": {
    "availability": "*[symmetry](#symmetry)==1* and exx calculation  (*[dft_fuctional](#dft_functional)==hse/hf/pbe0/scan0* or *[rpa](#rpa)==True*)",
    "default": "True",
    "description": "- False: only rotate k-space density matrix D(k) from irreducible k-points to accelerate diagonalization\n  - True: rotate both D(k) and Hexx(R) to accelerate both diagonalization and EXX calculation",
    "mdType": "Boolean",
    "section": "Exact Exchange (LCAO)",
    "type": "boolean",
    "unit": ""
  },
  "exx_thr_type": {
    "availability": "",
    "default": "`density`",
    "description": "The type of threshold used to judge whether the outer loop has converged in the separate loop EXX calculation.\n  - energy: use the change of exact exchange energy to judge convergence.\n  - density: if the change of charge density difference between two successive outer loop iterations is seen as converged according to *[scf_thr](#scf_thr)*, then the outer loop is seen as converged.",
    "enum": [
      "energy",
      "density"
    ],
    "mdType": "String",
    "section": "Exact Exchange (PW)",
    "type": "string",
    "unit": ""
  },
  "exx_v_grad_r_threshold": {
    "availability": "",
    "default": "1E-1",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). With the approximation $\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}$, the four-center integral in Fock exchange is expressed as $(ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}$, where $V_{ab}=(P_{a}|P_{b})$ is a double-center integral. $\\nabla V_{ab} *R_{ab}$ is used in force and stress. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_v_grad_threshold": {
    "availability": "",
    "default": "1E-1",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). With the approximation $\\Phi_{i}\\Phi_{k}\\sim C^{a}_{ik}P_{a}$, the four-center integral in Fock exchange is expressed as $(ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}$, where $V_{ab}=(P_{a}|P_{b})$ is a double-center integral. $\\nabla V_{ab}$ is used in force. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exx_v_threshold": {
    "availability": "",
    "default": "1E-1",
    "description": "See also the entry [exx_pca_threshold](#exx_pca_threshold). With the approximation $\\Phi_{i}\\Phi_{k}\\sim \\sum_{a} C^{a}_{ik}P_{a}$, the four-center integral in Fock exchange is expressed as $(ik|jl)=\\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}$, where $V_{ab}=(P_{a}|P_{b})$ is a double-center integral. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "exxace": {
    "availability": "*[exx_separate_loop](#exx_separate_loop)==True*.",
    "default": "True",
    "description": "Whether to use the ACE method (https://doi.org/10.1021/acs.jctc.6b00092) to accelerate the calculation the Fock exchange matrix. Should be set to true most of the time.\n  - True: Use the ACE method to calculate the Fock exchange operator.\n  - False: Use the traditional method to calculate the Fock exchange operator.",
    "mdType": "Boolean",
    "section": "Exact Exchange (PW)",
    "type": "boolean",
    "unit": ""
  },
  "fft_mode": {
    "availability": "",
    "default": "0",
    "description": "Set the mode of FFTW.\n  - 0: FFTW_ESTIMATE\n  - 1: FFTW_MEASURE\n  - 2: FFTW_PATIENT\n  - 3: FFTW_EXHAUSTIVE",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "fixed_atoms": {
    "availability": "",
    "default": "False",
    "description": "- True: The direct coordinates of atoms will be preserved during variable-cell relaxation.\n  - False: No restrictions are exerted on positions of all atoms. However, users can still fix certain components of certain atoms by using the `m` keyword in `STRU` file. For the latter option, check the end of this [instruction](stru.md).",
    "mdType": "Boolean",
    "section": "Geometry relaxation",
    "type": "boolean",
    "unit": ""
  },
  "fixed_axes": {
    "availability": "Only used when `calculation` is set to `cell-relax`",
    "default": "None",
    "dependencies": {
      "calculation": "cell",
      "relax_new": false
    },
    "description": "Specifies which cell degrees of freedom are fixed during variable-cell relaxation. The available options depend on the [relax_new](#relax_new) setting:\n\n  **When `relax_new = True` (default)**, all options are available:\n  - `None`: Default; all cell parameters can relax freely\n  - `volume`: Relaxation with fixed volume (allows shape changes)\n  - `shape`: Fix shape but allow volume changes (hydrostatic pressure only)\n  - `a`: Fix the a-axis lattice vector during relaxation\n  - `b`: Fix the b-axis lattice vector during relaxation\n  - `c`: Fix the c-axis lattice vector during relaxation\n  - `ab`: Fix both a and b axes during relaxation\n  - `ac`: Fix both a and c axes during relaxation\n  - `bc`: Fix both b and c axes during relaxation\n\n  **When `relax_new = False`**, all options are now available:\n  - `None`: Default; all cell parameters can relax freely\n  - `volume`: Relaxation with fixed volume (allows shape changes). Volume is preserved by rescaling the lattice after each update.\n  - `shape`: Fix shape but allow volume changes (hydrostatic pressure only). Stress tensor is replaced with isotropic pressure.\n  - `a`, `b`, `c`, `ab`, `ac`, `bc`: Fix specific lattice vectors. Gradients for fixed vectors are set to zero.",
    "enum": [
      "None",
      "volume",
      "shape",
      "a",
      "b",
      "c",
      "ab",
      "ac",
      "bc"
    ],
    "mdType": "String",
    "section": "Geometry relaxation",
    "type": "string",
    "unit": ""
  },
  "fixed_ibrav": {
    "availability": "Can be used with both `relax_new = True` and `relax_new = False`. A specific [latname](#latname) must be provided.",
    "default": "False",
    "description": "- True: the lattice type will be preserved during relaxation. The lattice vectors are reconstructed to match the specified Bravais lattice type after each update.\n  - False: No restrictions are exerted during relaxation in terms of lattice type\n\n> Note: it is possible to use `fixed_ibrav` with `fixed_axes`, but please make sure you know what you are doing. For example, if we are doing relaxation of a simple cubic lattice (`latname` = \"sc\"), and we use `fixed_ibrav` along with `fixed_axes` = \"volume\", then the cell is never allowed to move and as a result, the relaxation never converges. When both are used, `fixed_ibrav` is applied first, then `fixed_axes = \"volume\"` rescaling is applied.",
    "mdType": "Boolean",
    "section": "Geometry relaxation",
    "type": "boolean",
    "unit": ""
  },
  "force_thr": {
    "availability": "",
    "default": "0.001",
    "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to [force_thr_ev](#force_thr_ev) except for the unit, you can choose either you like.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "Ry/Bohr (25.7112 eV/Angstrom)"
  },
  "force_thr_ev": {
    "availability": "",
    "default": "0.0257112",
    "description": "Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to [force_thr](#force_thr) except for the unit. You may choose either you like.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "eV/Angstrom (0.03889 Ry/Bohr)"
  },
  "force_zero_out": {
    "availability": "",
    "default": "0.0",
    "description": "The atomic forces that are smaller than `force_zero_out` will be treated as zero.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "eV/Angstrom"
  },
  "gamma_only": {
    "availability": "Only used in localized orbitals set",
    "default": "0",
    "description": "Whether to use gamma_only algorithm.\n  - 0: more than one k-point is used and the ABACUS is slower compared to the gamma only algorithm.\n  - 1: ABACUS uses gamma only, the algorithm is faster and you don't need to specify the k-points file.\n\n  Note: If gamma_only is set to 1, the KPT file will be overwritten. So make sure to turn off gamma_only for multi-k calculations.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "gate_flag": {
    "availability": "",
    "default": "false",
    "description": "Controls the addition of compensating charge by a charged plate for charged cells.\n  - true: A charged plate is placed at the **zgate** position to add compensating charge. The direction is determined by **efield_dir**.\n  - false: No compensating charge is added.",
    "mdType": "Boolean",
    "section": "Gate field (compensating charge)",
    "type": "boolean",
    "unit": ""
  },
  "gdir": {
    "availability": "",
    "default": "3",
    "description": "The direction of the polarization in the lattice vector for Berry phase calculation\n  - 1: Calculate the polarization in the direction of the lattice vector a_1 defined in the STRU file.\n  - 2: Calculate the polarization in the direction of the lattice vector a_2 defined in the STRU file.\n  - 3: Calculate the polarization in the direction of the lattice vector a_3 defined in the STRU file.",
    "enum": [
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "Berry phase and wannier90 interface",
    "type": "integer",
    "unit": ""
  },
  "hubbard_u": {
    "availability": "",
    "default": "0.0",
    "description": "Specifies the Hubbard Coulomb interaction parameter U (eV) in plus U correction, which should be specified for each atom unless the Yukawa potential is used.\n\n> Note: Since only the simplified scheme by Duradev is implemented, the 'U' here is actually U-effective, which is given by Hubbard U minus Hund J.",
    "mdType": "Real",
    "section": "DFT+*U* correction",
    "type": "number",
    "unit": ""
  },
  "if_separate_k": {
    "availability": "For both PW and LCAO. When `basis_type = pw`, used if `out_pchg` is set. When `basis_type = lcao`, used only when `calculation = get_pchg` and `gamma_only = 0`.",
    "default": "false",
    "dependencies": {
      "basis_type": "lcao"
    },
    "description": "Specifies whether to write the partial charge densities for all k-points to individual files or merge them. **Warning**: Enabling symmetry may produce unwanted results due to reduced k-point weights and symmetry operations in real space. Therefore when calculating partial charge densities, if you are not sure what you want exactly, it is strongly recommended to set `symmetry = -1`. It is noteworthy that your `symmetry` setting should remain the same as that in the SCF procedure.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "imp_sol": {
    "availability": "",
    "default": "False",
    "description": "Calculate implicit solvation correction",
    "mdType": "Boolean",
    "section": "Implicit solvation model",
    "type": "boolean",
    "unit": ""
  },
  "init_chg": {
    "availability": "",
    "default": "atomic",
    "description": "This variable is used for both plane wave set and localized orbitals set. It indicates the type of starting density.\n\n  - atomic: the density is starting from the summation of the atomic density of single atoms.\n  - file: the density will be read in from a binary file `charge-density.dat` first. If it does not exist, the charge density will be read in from cube files. When you do `nspin=1` calculation, you only need the density file `chg.cube`. For `nspin=2 or 4` calculation, you need the density file `chgs1.cube` and `chgs2.cube` (and `chgs3.cube`, `chgs4.cube` if needed). The density file should be output with these names if you set out_chg = 1 in INPUT file.\n  - wfc: the density will be calculated by wavefunctions and occupations. Wavefunctions are read in from binary files `wf*.dat` (see [out_wfc_pw](#out_wfc_pw)) while occupations are read in from file `eig.txt`.\n  - dm: the density will be calculated by real space density matrix(DMR) of LCAO base. DMR is read in from file `dmrs1_nao.csr` in directory [read_file_dir](#read_file_dir).\n  - hr: the real space Hamiltonian matrix(HR) will be read in from file `hrs1_nao.csr` in directory [read_file_dir](#read_file_dir), and DMR and charge density will be calculated from it.\n  - auto: Abacus first attempts to read the density from a file; if not found, it defaults to using atomic density.",
    "enum": [
      "atomic",
      "file",
      "wfc",
      "dm",
      "hr",
      "auto"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "init_vecpot_file": {
    "availability": "",
    "default": "False",
    "description": "Initialize vector potential through file or not.\n  - True: Initialize vector potential from file `At.dat` (unit: a.u.). It consists of four columns, representing the step number and vector potential on each direction.\n  - False: Calculate vector potential by integrating the electric field.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "init_vel": {
    "availability": "",
    "default": "False",
    "description": "- True: read the atom velocity (atomic unit : 1 a.u. = 21.877 Angstrom/fs) from the atom file (`STRU`) and determine the initial temperature [md_tfirst](#md_tfirst-md_tlast).  If [md_tfirst](#md_tfirst-md_tlast) is unset or less than zero, `init_vel` is autoset to be `true`.\n  - False: assign value to atom velocity using Gaussian distributed random numbers.",
    "mdType": "Boolean",
    "section": "System variables",
    "type": "boolean",
    "unit": ""
  },
  "init_wfc": {
    "availability": "",
    "default": "atomic",
    "description": "The type of the starting wave functions.\n\n  Available options are:\n\n  - atomic: from atomic pseudo wave functions. If they are not enough, other wave functions are initialized with random numbers.\n  - atomic+random: add small random numbers on atomic pseudo-wavefunctions\n  - file: from binary files `wf*.dat`, which are output by setting [out_wfc_pw](#out_wfc_pw) to `2`.\n  - random: random numbers\n  - nao: from numerical atomic orbitals. If they are not enough, other wave functions are initialized with random numbers.\n  - nao+random: add small random numbers on numerical atomic orbitals\n\n  > Only the `file` option is useful for the lcao basis set, which is mostly used when [calculation](#calculation) is set to `get_wf` and `get_pchg`. See more details in [out_wfc_lcao](#out_wfc_lcao).",
    "enum": [
      "atomic",
      "atomic+random",
      "file",
      "random",
      "nao",
      "nao+random"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "initsto_ecut": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0.0",
    "description": "Stochastic wave functions are initialized in a large box generated by \"4*`initsto_ecut`\". `initsto_ecut` should be larger than [ecutwfc](#ecutwfc). In this method, SDFT results are the same when using different cores. Besides, coefficients of the same G are the same when ecutwfc is rising to initsto_ecut. If it is smaller than [ecutwfc](#ecutwfc), it will be turned off.",
    "mdType": "Real",
    "section": "Electronic structure (SDFT)",
    "type": "number",
    "unit": "Ry"
  },
  "initsto_freq": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0",
    "description": "Frequency (once each initsto_freq steps) to generate new stochastic orbitals when running md.\n  - positive integer: Update stochastic orbitals\n  - 0:                Never change stochastic orbitals.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Electronic structure (SDFT)",
    "type": "integer",
    "unit": ""
  },
  "kpar": {
    "availability": "",
    "default": "1",
    "description": "Divide all processors into kpar groups, and k points will be distributed among each group. The value taken should be less than or equal to the number of k points as well as the number of MPI processes.",
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "kpoint_file": {
    "availability": "",
    "default": "KPT",
    "description": "The name of the k-point file that includes the k-point information of Brillouin zone.\n  - In atomic orbitals basis with `gamma_only` set to true, the `KPT` file is unnecessary, because a `KPT` file will be generated automatically.\n  - When more than one k-points are required, an explicit `KPT` file is mandatory.\n  - Refer to [Doc](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/kpt.md)",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "ks_solver": {
    "availability": "",
    "default": "- PW basis: cg.\n  - LCAO basis:\n    - genelpa (if compiling option `USE_ELPA` has been set)\n    - lapack (if compiling option `ENABLE_MPI` has not been set)\n    - scalapack_gvx (if compiling option `USE_ELPA` has not been set and compiling option `ENABLE_MPI` has been set)\n    - cusolver (if compiling option `USE_CUDA` has been set)",
    "description": "Choose the diagonalization methods for the Hamiltonian matrix expanded in a certain basis set.\n\n  For plane-wave basis,\n\n  - cg: The conjugate-gradient (CG) method.\n  - bpcg: The BPCG method, which is a block-parallel Conjugate Gradient (CG) method, typically exhibits higher acceleration in a GPU environment.\n  - dav: The Davidson algorithm.\n  - dav_subspace: The Davidson algorithm without orthogonalization operation, this method is the most recommended for efficiency. `pw_diag_ndim` can be set to 2 for this method.\n\n  For numerical atomic orbitals basis,\n\n  - lapack: Use LAPACK to diagonalize the Hamiltonian, only used for serial version\n  - genelpa: Use GEN-ELPA to diagonalize the Hamiltonian.\n  - scalapack_gvx: Use Scalapack to diagonalize the Hamiltonian.\n  - cusolver: Use CUSOLVER to diagonalize the Hamiltonian, at least one GPU is needed.\n  - cusolvermp: Use CUSOLVER to diagonalize the Hamiltonian, supporting multi-GPU devices. Note that you should set the number of MPI processes equal to the number of GPUs.\n  - elpa: The ELPA solver supports both CPU and GPU. By setting the `device` to GPU, you can launch the ELPA solver with GPU acceleration (provided that you have installed a GPU-supported version of ELPA, which requires you to manually compile and install ELPA, and the ABACUS should be compiled with -DUSE_ELPA=ON and -DUSE_CUDA=ON). The ELPA solver also supports multi-GPU acceleration.\n\n  If you set ks_solver=`genelpa` for basis_type=`pw`, the program will stop with an error message:\n\n  ```text\n  genelpa can not be used with plane wave basis.\n  ```\n\n  Then the user has to correct the input file and restart the calculation.",
    "enum": [
      "cg",
      "bpcg",
      "dav",
      "dav_subspace",
      "lapack",
      "genelpa",
      "scalapack_gvx",
      "cusolver",
      "cusolvermp",
      "elpa"
    ],
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "kspacing": {
    "availability": "",
    "default": "0.0",
    "description": "Set the smallest allowed spacing between k points, unit in 1/bohr. It should be larger than 0.0, and suggest smaller than 0.25. When you have set this value > 0.0, then the KPT file is unnecessary, and the number of K points nk_i = max(1, int(|b_i|/KSPACING_i)+1), where b_i is the reciprocal lattice vector. The default value 0.0 means that ABACUS will read the applied KPT file.\nIf only one value is set (such as `kspacing 0.5`), then kspacing values of a/b/c direction are all set to it; and one can also set 3 values to set the kspacing value for a/b/c direction separately (such as: `kspacing 0.5 0.6 0.7`).",
    "exclusiveMinimum": 0.0,
    "mdType": "Real",
    "section": "System variables",
    "type": "number",
    "unit": ""
  },
  "latname": {
    "availability": "",
    "default": "none",
    "description": "Specifies the type of Bravias lattice. When set to `none`, the three lattice vectors are supplied explicitly in STRU file. When set to a certain Bravais lattice type, there is no need to provide lattice vector, but a few lattice parameters might be required. For more information regarding this parameter, consult the [page on STRU file](stru.md).\n\n  Available options are:\n  - none: free structure\n  - sc: simple cubic\n  - fcc: face-centered cubic\n  - bcc: body-centered cubic\n  - hexagonal: hexagonal\n  - trigonal: trigonal\n  - st: simple tetragonal\n  - bct: body-centered tetragonal\n  - so: orthorhombic\n  - baco: base-centered orthorhombic\n  - fco: face-centered orthorhombic\n  - bco: body-centered orthorhombic\n  - sm: simple monoclinic\n  - bacm: base-centered monoclinic\n  - triclinic: triclinic",
    "enum": [
      "none",
      "sc",
      "fcc",
      "bcc",
      "hexagonal",
      "trigonal",
      "st",
      "bct",
      "so",
      "baco",
      "fco",
      "bco",
      "sm",
      "bacm",
      "triclinic"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "lcao_dk": {
    "availability": "",
    "default": "0.01",
    "description": "the interval of k points for two-center integrals. The two-center integration table are obtained via a k space integral on a uniform grid with spacing `lcao_dk`.",
    "mdType": "Real",
    "section": "Numerical atomic orbitals related variables",
    "type": "number",
    "unit": "Bohr${}^{-1}$"
  },
  "lcao_dr": {
    "availability": "",
    "default": "0.01",
    "description": "r spacing of the integration table of two-center integrals.",
    "mdType": "Real",
    "section": "Numerical atomic orbitals related variables",
    "type": "number",
    "unit": "Bohr"
  },
  "lcao_ecut": {
    "availability": "",
    "default": "`ecutwfc`",
    "description": "Energy cutoff (in Ry) for two-center integrals in LCAO. The two-center integration table are obtained via a k space integral whose upper limit is about sqrt(`lcao_ecut`).",
    "mdType": "Real",
    "section": "Numerical atomic orbitals related variables",
    "type": "number",
    "unit": ""
  },
  "lcao_rmax": {
    "availability": "",
    "default": "30",
    "description": "Maximum distance for the two-center integration table.",
    "mdType": "Real",
    "section": "Numerical atomic orbitals related variables",
    "type": "number",
    "unit": "Bohr"
  },
  "ldos_line": {
    "availability": "",
    "default": "0.0 0.0 0.0 0.0 0.0 1.0 100",
    "description": "Specify the path of the three-dimensional space and display LDOS in the form of a two-dimensional color chart, see details in [out_ldos](#out_ldos). The first three paramenters are the direct coordinates of the start point, the next three paramenters are the direct coordinates of the end point, and the final one is the number of points along the path, whose default is 100.",
    "mdType": "Real*6 Integer(optional)",
    "section": "Density of states",
    "type": "string",
    "unit": ""
  },
  "lj_epsilon": {
    "availability": "",
    "default": "No default",
    "description": "The vector representing the $\\epsilon$ matrix for Leonard Jones potential. See details in [lj_rule](#lj_rule).",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "eV"
  },
  "lj_eshift": {
    "availability": "",
    "default": "False",
    "description": "It True, the LJ potential is shifted by a constant such that it is zero at the cut-off distance.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "lj_rcut": {
    "availability": "",
    "default": "No default",
    "description": "Cut-off radius for Leonard Jones potential, beyond which the interaction will be neglected. It can be a single value, which means that all pairs of atoms types share the same cut-off radius. Otherwise, it should be a multiple-component vector, containing $N(N+1)/2$ values, see details in [lj_rule](#lj_rule).",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "Angstrom"
  },
  "lj_rule": {
    "availability": "",
    "default": "2",
    "description": "The Lennard-Jones potential between two atoms equals:\n  $$V_{LJ}(r_{ij})=4\\epsilon_{ij}\\left(\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right)=\\frac{C_{ij}^{(12)}}{{r_{ij}}^{12}}-\\frac{C_{ij}^{(6)}}{{r_{ij}}^{6}}.$$\n\n  The parameters [lj_epsilon](#lj_epsilon) and [lj_sigma](#lj_sigma) should be multiple-component vectors. For example, there are two choices in the calculations of 3 atom species:\n\n  Supply six-component vectors that describe the interactions between all possible atom pairs. The six-component vectors represent lower triangular symmetric matrixs, and the correspondence between the vector component $\\sigma _k$ and the matrix element $\\sigma (i,j)$ is\n  $$k= i(i+1)/2 +j$$\n\n  Supply three-component vectors that describe the interactions between atoms of the same species. In this case, two types of combination rules can be used to construct non-diagonal elements in the parameter matrix.\n\n  - 1: geometric average:\n  $$\\begin{array}{rcl}C_{ij}^{(6)}&=&\\left(C_{ii}^{(6)}C_{jj}^{(6)}\\right)^{1/2}\\\\C_{ij}^{(12)}&=&\\left(C_{ii}^{(12)}C_{jj}^{(12)}\\right)^{1/2}\\end{array}$$\n\n  - 2: arithmetic average:\n  $$\\begin{array}{rcl}\\sigma_{ij}&=&\\frac{1}{2}\\left(\\sigma_{ii}+\\sigma_{jj}\\right)\\\\ \\epsilon_{ij}&=&\\left(\\epsilon_{ii}\\epsilon_{jj}\\right)^{1/2}\\end{array}$$",
    "enum": [
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "lj_sigma": {
    "availability": "",
    "default": "No default",
    "description": "The vector representing the $\\sigma$ matrix for Leonard Jones potential. See details in [lj_rule](#lj_rule).",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "Angstrom"
  },
  "lmaxmax": {
    "availability": "",
    "default": "2.",
    "description": "If not equals to 2, then the maximum l channels on LCAO is set to lmaxmax. If 2, then the number of l channels will be read from the LCAO data sets. Normally no input should be supplied for this variable so that it is kept as its default.",
    "mdType": "Integer",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "lr_init_xc_kernel (Under Development Feature)": {
    "availability": "",
    "default": "\"default\"",
    "description": "The method to initalize the xc kernel.\n  - \"default\": Calculate xc kerenel ($f_\\text{xc}$) from the ground-state charge density.\n  - \"file\": Read the xc kernel $f_\\text{xc}$ on grid from the provided files. The following words should be the paths of \".cube\" files, where the first 1 (*[nspin](#nspin)==1*) or 3 (*[nspin](#nspin)==2*, namely spin-aa, spin-ab and spin-bb) will be read in. The parameter [xc_kernel](#xc_kernel) will be invalid. Now only LDA-type kernel is supproted as the potential will be calculated by directly multiplying the transition density.\n  - \"from_charge_file\": Calculate fxc from the charge density read from the provided files. The following words should be the paths of \".cube\" files, where the first [nspin]($nspin) files will be read in.",
    "mdType": "String",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "lr_nstates (Under Development Feature)": {
    "availability": "",
    "default": "0",
    "description": "The number of 2-particle states to be solved",
    "mdType": "Integer",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "integer",
    "unit": ""
  },
  "lr_solver (Under Development Feature)": {
    "availability": "",
    "default": "dav",
    "description": "The method to solve the Casida equation $AX=\\Omega X$ in LR-TDDFT under Tamm-Dancoff approximation (TDA), where $A_{ai,bj}=(\\epsilon_a-\\epsilon_i)\\delta_{ij}\\delta_{ab}+(ai|f_{Hxc}|bj)+\\alpha_{EX}(ab|ij)$ is the particle-hole excitation matrix and $X$ is the transition amplitude.\n  - `dav`/`dav_subspace`/ `cg`: Construct $AX$ and diagonalize the Hamiltonian matrix iteratively with Davidson/Non-ortho-Davidson/CG algorithm.\n  - `lapack`: Construct the full $A$ matrix and directly diagonalize with LAPACK.\n  - `spectrum`: Calculate absorption spectrum only without solving Casida equation. The `OUT.${suffix}/` directory should contain the\n  files for LR-TDDFT eigenstates and eigenvalues, i.e. `Excitation_Energy.dat` and `Excitation_Amplitude_${processor_rank}.dat`\n   output by setting `out_wfc_lr` to true.",
    "enum": [
      "lapack",
      "spectrum"
    ],
    "mdType": "String",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "lr_thr (Under Development Feature)": {
    "availability": "",
    "default": "1e-2",
    "description": "The convergence threshold of iterative diagonalization solver fo LR-TDDFT. It is a pure-math number with the same as [pw_diag_thr](#pw_diag_thr), but since the Casida equation is a one-shot eigenvalue problem, it is also the convergence threshold of LR-TDDFT.",
    "mdType": "Real",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "number",
    "unit": ""
  },
  "lr_unrestricted (Under Development Feature)": {
    "availability": "",
    "default": "False",
    "description": "Whether to use unrestricted construction for LR-TDDFT (the matrix size will be doubled).\n  - True:  Always use unrestricted LR-TDDFT.\n  - False: Use unrestricted LR-TDDFT only when the system is open-shell.",
    "mdType": "Boolean",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "boolean",
    "unit": ""
  },
  "lspinorb": {
    "availability": "",
    "default": "False",
    "description": "Whether to consider spin-orbit coupling (SOC) effect in the calculation.",
    "mdType": "Boolean",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "md_damp": {
    "availability": "",
    "default": "1.0",
    "description": "The damping parameter used to add fictitious force in the Langevin method.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "fs"
  },
  "md_dt": {
    "availability": "",
    "default": "1.0",
    "description": "The time step used in molecular dynamics calculations.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "fs"
  },
  "md_dumpfreq": {
    "availability": "",
    "default": "1",
    "description": "The output frequency of `OUT.${suffix}/MD_dump` in molecular dynamics calculations, which including the information of lattices and atoms.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_nraise": {
    "availability": "",
    "default": "1",
    "description": "- Anderson: The \"collision frequency\" parameter is given as 1/`md_nraise`.\n  - Berendsen: The \"rise time\" parameter is given in units of the time step: tau = `md_nraise`*`md_dt`, so `md_dt`/tau = 1/`md_nraise`.\n  - Rescale_v: Every `md_nraise` steps the current temperature is rescaled to the target temperature.",
    "enum": [
      "Anderson",
      "Berendsen",
      "Rescale_v"
    ],
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_nstep": {
    "availability": "",
    "default": "10",
    "description": "The total number of molecular dynamics steps.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_pchain": {
    "availability": "",
    "default": "1",
    "description": "The number of thermostats coupled with the barostat in the NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_pcouple": {
    "availability": "",
    "default": "none",
    "description": "The coupled lattice vectors will scale proportionally in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.\n  - none: Three lattice vectors scale independently.\n  - xyz: Lattice vectors x, y, and z scale proportionally.\n  - xy: Lattice vectors x and y scale proportionally.\n  - xz: Lattice vectors x and z scale proportionally.\n  - yz: Lattice vectors y and z scale proportionally.",
    "enum": [
      "none",
      "xyz",
      "xy",
      "xz",
      "yz"
    ],
    "mdType": "String",
    "section": "Molecular dynamics",
    "type": "string",
    "unit": ""
  },
  "md_pfirst": {
    "availability": "",
    "default": "-1.0",
    "description": "The target pressure used in NPT ensemble simulations, the default value of `md_plast` is `md_pfirst`. If `md_plast` is set to be different from `md_pfirst`, ABACUS will automatically change the target pressure from `md_pfirst` to `md_plast`.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "kbar"
  },
  "md_pfreq": {
    "availability": "",
    "default": "1/400/md_dt",
    "description": "The frequency of pressure oscillations during the NPT ensemble simulation. If it is too large, the pressure will fluctuate violently; if it is too small, the pressure will take a very long time to equilibrate with the atomic system.\n\n  Note: It is a system-dependent empirical parameter. An improper choice might lead to the failure of jobs.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "$\\mathrm{kbar^{-1}}$"
  },
  "md_plast": {
    "availability": "",
    "default": "-1.0",
    "description": "The target pressure used in NPT ensemble simulations, the default value of `md_plast` is `md_pfirst`. If `md_plast` is set to be different from `md_pfirst`, ABACUS will automatically change the target pressure from `md_pfirst` to `md_plast`.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "kbar"
  },
  "md_pmode": {
    "availability": "",
    "default": "iso\n0 -->",
    "description": "Specify the cell fluctuation mode in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.\n  - iso: The three diagonal elements of the lattice are fluctuated isotropically.\n  - aniso: The three diagonal elements of the lattice are fluctuated anisotropically.\n  - tri: The lattice must be a lower-triangular matrix, and all six freedoms are fluctuated.\nDetermine the precision level of variable-cell molecular dynamics calculations.\n  - 0: FFT grids do not change, only G vectors and K vectors are changed due to the change of lattice vector. This level is suitable for cases where the variation of the volume and shape is not large, and the efficiency is relatively higher.\n  - 2: FFT grids change per step. This level is suitable for cases where the variation of the volume and shape is large, such as the MSST method. However, accuracy comes at the cost of efficiency.",
    "enum": [
      "iso",
      "aniso",
      "tri",
      "0",
      "2"
    ],
    "mdType": "String\nInteger",
    "section": "Molecular dynamics",
    "type": "string",
    "unit": ""
  },
  "md_restart": {
    "availability": "",
    "default": "False",
    "description": "Control whether to restart molecular dynamics calculations and time-dependent density functional theory calculations.\n  - True: ABACUS will read in `${read_file_dir}/Restart_md.txt` to determine the current step `${md_step}`, then read in the corresponding `STRU_MD_${md_step}` in the folder `OUT.$suffix/STRU/` automatically. For tddft, ABACUS will also read in `WFC_NAO_K${kpoint}` of the last step (You need to set out_wfc_lcao=1 and out_app_flag=0 to obtain this file).\n  - False: ABACUS will start molecular dynamics calculations normally from the first step.",
    "mdType": "Boolean",
    "section": "Molecular dynamics",
    "type": "boolean",
    "unit": ""
  },
  "md_restartfreq": {
    "availability": "",
    "default": "5",
    "description": "The output frequency of `OUT.${suffix}/Restart_md.txt` and structural files in the directory `OUT.${suffix}/STRIU/`, which are used to restart molecular dynamics calculations, see [md_restart](#md_restart) in detail.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_seed": {
    "availability": "",
    "default": "-1",
    "description": "The random seed to initialize random numbers used in molecular dynamics calculations.\n  - \\< 0: No srand() function is called.\n  - \\>= 0: The function srand(md_seed) is called.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_tchain": {
    "availability": "",
    "default": "1",
    "description": "Number of thermostats coupled with the particles in the NVT/NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.",
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "md_tfirst": {
    "availability": "",
    "default": "No default",
    "description": "The temperature used in molecular dynamics calculations.\n\n  If `md_tfirst` is unset or less than zero, [init_vel](#init_vel) is autoset to be `true`. If [init_vel](#init_vel) is `true`, the initial temperature will be determined by the velocities read from `STRU`. In this case, if velocities are unspecified in `STRU`, the initial temperature is set to zero.\n\n  If `md_tfirst` is set to a positive value and [init_vel](#init_vel) is `true` simultaneously, please make sure they are consistent, otherwise abacus will exit immediately.\n\n  Note that `md_tlast` is only used in NVT/NPT simulations. If `md_tlast` is unset or less than zero, `md_tlast` is set to `md_tfirst`. If `md_tlast` is set to be different from `md_tfirst`, ABACUS will automatically change the temperature from `md_tfirst` to `md_tlast`.",
    "exclusiveMinimum": 0,
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "K"
  },
  "md_tfreq": {
    "availability": "",
    "default": "1/40/md_dt",
    "description": "Control the frequency of temperature oscillations during the simulation. If it is too large, the temperature will fluctuate violently; if it is too small, the temperature will take a very long time to equilibrate with the atomic system.\n\n  Note: It is a system-dependent empirical parameter, ranging from 1/(40\\*md_dt) to 1/(100\\*md_dt). An improper choice might lead to the failure of jobs.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "$\\mathrm{fs^{-1}}$"
  },
  "md_thermostat": {
    "availability": "",
    "default": "nhc",
    "description": "Specify the temperature control method used in NVT ensemble.\n\n  - nhc: Nose-Hoover chain, see [md_tfreq](#md_tfreq) and [md_tchain](#md_tchain) in detail.\n  - anderson: Anderson thermostat, see [md_nraise](#md_nraise) in detail.\n  - berendsen: Berendsen thermostat, see [md_nraise](#md_nraise) in detail.\n  - rescaling: velocity Rescaling method 1, see [md_tolerance](#md_tolerance) in detail.\n  - rescale_v: velocity Rescaling method 2, see [md_nraise](#md_nraise) in detail.",
    "enum": [
      "nhc",
      "anderson",
      "berendsen",
      "rescaling",
      "rescale_v"
    ],
    "mdType": "String",
    "section": "Molecular dynamics",
    "type": "string",
    "unit": ""
  },
  "md_tlast": {
    "availability": "",
    "default": "No default",
    "description": "The temperature used in molecular dynamics calculations.\n\n  If `md_tfirst` is unset or less than zero, [init_vel](#init_vel) is autoset to be `true`. If [init_vel](#init_vel) is `true`, the initial temperature will be determined by the velocities read from `STRU`. In this case, if velocities are unspecified in `STRU`, the initial temperature is set to zero.\n\n  If `md_tfirst` is set to a positive value and [init_vel](#init_vel) is `true` simultaneously, please make sure they are consistent, otherwise abacus will exit immediately.\n\n  Note that `md_tlast` is only used in NVT/NPT simulations. If `md_tlast` is unset or less than zero, `md_tlast` is set to `md_tfirst`. If `md_tlast` is set to be different from `md_tfirst`, ABACUS will automatically change the temperature from `md_tfirst` to `md_tlast`.",
    "exclusiveMinimum": 0,
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "K"
  },
  "md_tolerance": {
    "availability": "",
    "default": "100.0",
    "description": "The temperature tolerance for velocity rescaling. Velocities are rescaled if the current and target temperature differ more than `md_tolerance`.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "K"
  },
  "md_type": {
    "availability": "",
    "default": "nvt",
    "description": "Control the algorithm to integrate the equation of motion for molecular dynamics (MD), see [md.md](../md.md#molecular-dynamics) in detail.\n\n  - fire: a MD-based relaxation algorithm, named fast inertial relaxation engine.\n  - nve: NVE ensemble with velocity Verlet algorithm.\n  - nvt: NVT ensemble, see [md_thermostat](#md_thermostat) in detail.\n  - npt: Nose-Hoover style NPT ensemble, see [md_pmode](#md_pmode) in detail.\n  - langevin: NVT ensemble with Langevin thermostat, see [md_damp](#md_damp) in detail.\n  - msst: MSST method, see [msst_direction](#msst_direction), [msst_vel](#msst_vel), [msst_qmass](#msst_qmass), [msst_vis](#msst_vis), [msst_tscale](#msst_tscale) in detail.",
    "enum": [
      "fire",
      "nve",
      "nvt",
      "npt",
      "langevin",
      "msst"
    ],
    "mdType": "String",
    "section": "Molecular dynamics",
    "type": "string",
    "unit": ""
  },
  "mem_saver": {
    "availability": "Used only for nscf calculations with plane wave basis set.",
    "default": "0",
    "description": "Save memory when performing nscf calculations.\n  - 0: no memory saving techniques are used.\n  - 1: a memory saving technique will be used for many k point calculations.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "System variables",
    "type": "boolean",
    "unit": ""
  },
  "method_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "2",
    "description": "Different methods to do stochastic DFT\n  - 1: Calculate $T_n(\\hat{h})\\ket{\\chi}$ twice, where $T_n(x)$ is the n-th order Chebyshev polynomial and $\\hat{h}=\\frac{\\hat{H}-\\bar{E}}{\\Delta E}$ owning eigenvalues $\\in(-1,1)$. This method cost less memory but is slower.\n  - 2: Calculate $T_n(\\hat{h})\\ket{\\chi}$ once but needs much more memory. This method is much faster. Besides, it calculates $N_e$ with $\\bra{\\chi}\\sqrt{\\hat f}\\sqrt{\\hat f}\\ket{\\chi}$, which needs a smaller [nche_sto](#nche_sto). However, when the memory is not enough, only method 1 can be used.\n  - other: use 2",
    "enum": [
      "1",
      "2",
      "other"
    ],
    "mdType": "Integer",
    "section": "Electronic structure (SDFT)",
    "type": "integer",
    "unit": ""
  },
  "min_dist_coef": {
    "availability": "",
    "default": "0.2",
    "description": "A factor related to the allowed minimum distance between two atoms. At the beginning, ABACUS will check the structure, and if the distance of two atoms is shorter than min_dist_coef*(standard covalent bond length), we think this structure is unreasonable. If you want to calculate some structures in extreme conditions like high pressure, you should set this parameter as a smaller value or even 0.",
    "mdType": "Real",
    "section": "System variables",
    "type": "number",
    "unit": ""
  },
  "mixing_angle": {
    "availability": "Only relevant for non-colinear calculations `nspin=4`.",
    "default": "-10.0\n\nNote: In new angle mixing, you should set `mixing_beta_mag >> mixing_beta`. The setup of `mixing_beta=0.2`, `mixing_beta_mag=1.0` usually works well.",
    "description": "Normal broyden mixing can give the converged result for a given magnetic configuration. If one is not interested in the energies of a given magnetic configuration but wants to determine the ground state by relaxing the magnetic moments’ directions, one cannot rely on the standard Broyden mixing algorithm. To enhance the ability to find correct magnetic configuration for non-colinear calculations, ABACUS implements a promising mixing method proposed by J. Phys. Soc. Jpn. 82 (2013) 114706. Here, `mixing_angle` is the angle mixing parameter. In fact, only `mixing_angle=1.0` is implemented currently.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_beta": {
    "availability": "",
    "default": "0.8 for `nspin=1`, 0.4 for `nspin=2` and `nspin=4`.",
    "description": "In general, the formula of charge mixing can be written as $\\rho_{new} = \\rho_{old} + \\beta * \\rho_{update}$, where $\\rho_{new}$ represents the new charge density after charge mixing, $\\rho_{old}$ represents the charge density in previous step, $\\rho_{update}$ is obtained through various mixing methods, and $\\beta$ is set by the parameter `mixing_beta`. A lower value of 'mixing_beta' results in less influence of $\\rho_{update}$ on $\\rho_{new}$, making the self-consistent field (SCF) calculation more stable. However, it may require more steps to achieve convergence.\nWe recommend the following options:\n  - 0.8: `nspin=1`\n  - 0.4: `nspin=2` and `nspin=4`\n  - 0: keep charge density unchanged, usually used for restarting with `init_chg=file` or testing.\n  - 0.1 or less: if convergence of SCF calculation is difficult to reach, please try `0 < mixing_beta < 0.1`.\n\n  Note: For low-dimensional large systems, the setup of `mixing_beta=0.1`, `mixing_ndim=20`, and `mixing_gg0=1.0` usually works well.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_beta_mag": {
    "availability": "",
    "default": "`4*mixing_beta`, but the maximum value is 1.6.\n\nNote that `mixing_beta_mag` is not euqal to `mixing_beta` means that $\\rho_{up}$ and $\\rho_{down}$ mix independently from each other. This setting will fail for one case where the $\\rho_{up}$ and $\\rho_{down}$ of the ground state refers to different Kohn-Sham orbitals. For an atomic system, the $\\rho_{up}$ and $\\rho_{down}$ of the ground state refers to different Kohn-Sham orbitals. We all know Kohn-Sham orbitals are orthogonal to each other. So the mixture of $\\rho_{up}$ and $\\rho_{down}$ should be exactly independent, otherwise SCF cannot find the ground state forever. To sum up, please make sure `mixing_beta_mag` and `mixing_gg0_mag` exactly euqal to `mixing_beta` and `mixing_gg0` if you calculate an atomic system.",
    "description": "Mixing parameter of magnetic density.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_dftu": {
    "availability": "Only relevant for DFT+U calculations.",
    "default": "False",
    "description": "Whether to mix the occupation matrices.\n  - True: The occupation matrices will also be mixed by plain mixing. From experience this is not very helpful if the +U calculation does not converge.\n  - False: The occupation matrices will not be mixed.",
    "mdType": "Boolean",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "mixing_dmr": {
    "availability": "Only for `mixing_restart>=0.0`",
    "default": "false",
    "description": "At n-th iteration which is calculated by `drho<mixing_restart`, SCF will start a mixing for real-space density matrix by using the same coefficiences as the mixing of charge density.",
    "mdType": "bool",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "mixing_gg0": {
    "availability": "",
    "default": "1.0",
    "description": "Whether to perfom Kerker scaling for charge density.\n  - >0: The high frequency wave vectors will be suppressed by multiplying a scaling factor $\\frac{k^2}{k^2+gg0^2}$. Setting `mixing_gg0 = 1.0` is normally a good starting point. Kerker preconditioner will be automatically turned off if `mixing_beta <= 0.1`.\n  - 0: No Kerker scaling is performed.\n\n  For systems that are difficult to converge, particularly metallic systems, enabling Kerker scaling may aid in achieving convergence.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_gg0_mag": {
    "availability": "",
    "default": "0.0",
    "description": "Whether to perfom Kerker preconditioner of magnetic density.\n  Note: we do not recommand to open Kerker preconditioner of magnetic density unless the system is too hard to converge.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_gg0_min": {
    "availability": "",
    "default": "0.1",
    "description": "The minimum kerker coefficient.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "mixing_ndim": {
    "availability": "",
    "default": "8",
    "description": "It indicates the mixing dimensions in Pulay or Broyden. Pulay and Broyden method use the density from previous mixing_ndim steps and do a charge mixing based on this density.\n\n  For systems that are difficult to converge, one could try increasing the value of 'mixing_ndim' to enhance the stability of the self-consistent field (SCF) calculation.",
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "mixing_restart": {
    "availability": "",
    "default": "0",
    "description": "If the density difference between input and output `drho` is smaller than `mixing_restart`, SCF will restart at next step which means SCF will restart by using output charge density from perivos iteration as input charge density directly, and start a new mixing. Notice that `mixing_restart` will only take effect once in one SCF.",
    "mdType": "double",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "mixing_tau": {
    "availability": "Only relevant for meta-GGA calculations.",
    "default": "False",
    "description": "Whether to mix the kinetic energy density.\n  - True: The kinetic energy density will also be mixed. It seems for general cases, SCF converges fine even without this mixing. However, if there is difficulty in converging SCF for meta-GGA, it might be helpful to turn this on.\n  - False: The kinetic energy density will not be mixed.",
    "mdType": "Boolean",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "mixing_type": {
    "availability": "",
    "default": "broyden",
    "description": "Charge mixing methods.\n  - plain: Just simple mixing.\n  - pulay: Standard Pulay method. [P. Pulay Chemical Physics Letters, (1980)](https://www.sciencedirect.com/science/article/abs/pii/0009261480803964)\n  - broyden: Simplified modified Broyden method. [D.D. Johnson Physical Review B (1988)](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807)\n\n  In general, the convergence of the Broyden method is slightly faster than that of the Pulay method.",
    "enum": [
      "plain",
      "pulay",
      "broyden"
    ],
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "msst_direction": {
    "availability": "",
    "default": "2",
    "description": "The direction of the shock wave in the MSST method.\n  - 0: x direction\n  - 1: y direction\n  - 2: z direction",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Molecular dynamics",
    "type": "integer",
    "unit": ""
  },
  "msst_qmass": {
    "availability": "",
    "default": "No default",
    "description": "Inertia of the extended system variable. You should set a number larger than 0.",
    "exclusiveMinimum": 0.0,
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "$\\mathrm{g^{2}/(mol^{2}*Angstrom^{4})}$"
  },
  "msst_tscale": {
    "availability": "",
    "default": "0.01",
    "description": "The reduction percentage of the initial temperature used to compress volume in the MSST method.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": ""
  },
  "msst_vel": {
    "availability": "",
    "default": "0.0",
    "description": "The velocity of the shock wave in the MSST method.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "Angstrom/fs"
  },
  "msst_vis": {
    "availability": "",
    "default": "0.0",
    "description": "Artificial viscosity in the MSST method.",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": "g/(mol\\*Angstrom\\*fs)"
  },
  "nb2d": {
    "availability": "",
    "default": "0",
    "description": "When using elpa or scalapack to solver the eigenvalue problem, the data should be distributed by the two-dimensional block-cyclic distribution. This paramter specifies the size of the block. It is valid for:\n  - [ks_solver](#ks_solver) is genelpa or scalapack_gvx. If nb2d is set to 0, then it will be automatically set in the program according to the size of atomic orbital basis:\n    - if size <= 500: nb2d = 1\n    - if 500 < size <= 1000: nb2d = 32\n    - if size > 1000: nb2d = 64;\n  - [ks_solver](#ks_solver) is dav_subspace, and [diag_subspace](#diag_subspace) is 1 or 2. It is the block size for the diagonization of subspace. If it is set to 0, then it will be automatically set in the program according to the number of band:\n    - if number of band > 500: nb2d = 32\n    - if number of band < 500: nb2d = 16",
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "nbands": {
    "availability": "",
    "default": "- nspin=1: max(1.2\\*occupied_bands, occupied_bands + 10)\n  - nspin=2: max(1.2\\*nelec_spin, nelec_spin + 10), in which nelec_spin = max(nelec_spin_up, nelec_spin_down)\n  - nspin=4: max(1.2\\*nelec, nelec + 20)",
    "description": "The number of Kohn-Sham orbitals to calculate. It is recommended to setup this value, especially when smearing techniques are utilized, more bands should be included.",
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "nbands_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "256",
    "description": "The number of stochastic orbitals\n  - \\> 0: Perform stochastic DFT.\n   Increasing the number of bands improves accuracy and reduces stochastic errors, which scale as $1/\\sqrt{N_{\\chi}}$;\n   To perform mixed stochastic-deterministic DFT, you should set [nbands](#nbands), which represents the number of KS orbitals.\n  - 0: Perform Kohn-Sham DFT.\n  - all: All complete basis sets are used to replace stochastic orbitals with the Chebyshev method (CT), resulting in the same results as KSDFT without stochastic errors.",
    "enum": [
      "0",
      "all"
    ],
    "mdType": "Integer or string",
    "section": "Electronic structure (SDFT)",
    "type": "string",
    "unit": ""
  },
  "nbspline": {
    "availability": "",
    "default": "-1",
    "description": "If set to a natural number, a Cardinal B-spline interpolation will be used to calculate Structure Factor. `nbspline` represents the order of B-spline basis and a larger one can get more accurate results but cost more.\n  It is turned off by default.",
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "nc_k": {
    "availability": "",
    "default": "0.00037",
    "description": "The value of the electron density at which the dielectric cavity forms",
    "mdType": "Real",
    "section": "Implicit solvation model",
    "type": "number",
    "unit": "$Bohr^{-3}$"
  },
  "nche_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "100",
    "description": "Chebyshev expansion orders for stochastic DFT.",
    "mdType": "Integer",
    "section": "Electronic structure (SDFT)",
    "type": "integer",
    "unit": ""
  },
  "ndx": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc.\n\n    Note: You must specify all three dimensions for this setting to be used.\n    Note: These parameters must be used combined with [nx,ny,nz](#nx-ny-nz). If [nx,ny,nz](#nx-ny-nz) are unset, ndx,ndy,ndz are used as [nx,ny,nz](#nx-ny-nz).",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "ndy": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc.\n\n    Note: You must specify all three dimensions for this setting to be used.\n    Note: These parameters must be used combined with [nx,ny,nz](#nx-ny-nz). If [nx,ny,nz](#nx-ny-nz) are unset, ndx,ndy,ndz are used as [nx,ny,nz](#nx-ny-nz).",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "ndz": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid (for the dense part of charge density in ultrasoft pseudopotential) points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutwfc.\n\n    Note: You must specify all three dimensions for this setting to be used.\n    Note: These parameters must be used combined with [nx,ny,nz](#nx-ny-nz). If [nx,ny,nz](#nx-ny-nz) are unset, ndx,ndy,ndz are used as [nx,ny,nz](#nx-ny-nz).",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "nelec": {
    "availability": "",
    "default": "0.0",
    "description": "- 0.0: The total number of electrons will be calculated by the sum of valence electrons (i.e. assuming neutral system).\n  - `>0.0`: this denotes the total number of electrons in the system. Must be less than 2*nbands.",
    "exclusiveMaximum": 2.0,
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "nelec_delta": {
    "availability": "",
    "default": "0.0",
    "description": "The total number of electrons will be calculated by `nelec`+`nelec_delta`.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "nnkpfile": {
    "availability": "",
    "default": "seedname.nnkp",
    "description": "The file name generated when running \"wannier90 -pp ...\" command",
    "mdType": "String",
    "section": "Berry phase and wannier90 interface",
    "type": "string",
    "unit": ""
  },
  "nocc (Under Development Feature)": {
    "availability": "",
    "default": "[nband](#nband)",
    "description": "The number of occupied orbitals (up to HOMO) used in the LR-TDDFT calculation.",
    "mdType": "Integer",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "integer",
    "unit": ""
  },
  "noncolin": {
    "availability": "",
    "default": "False",
    "description": "Whether to allow non-collinear magnetic moments, where magnetization can point in arbitrary directions (x, y, z components) rather than being constrained to the z-axis.",
    "mdType": "Boolean",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "npart_sto": {
    "availability": "[method_sto](#method_sto) = `2` and [out_dos](#out_dos) = 1 or [cal_cond](#cal_cond) = `True`",
    "default": "1",
    "description": "Make memory cost to 1/npart_sto times of the previous one when running the post process of SDFT like DOS or conductivities.",
    "mdType": "Integer",
    "section": "Electronic structure (SDFT)",
    "type": "integer",
    "unit": ""
  },
  "nspin": {
    "availability": "",
    "default": "1",
    "description": "The number of spin components of wave functions.\n  - 1: Spin degeneracy\n  - 2: Collinear spin polarized.\n  - 4: For the case of [noncollinear polarized](../scf/spin.md#noncollinear-spin-polarized-calculations), nspin will be automatically set to 4 without being specified by the user.",
    "enum": [
      "1",
      "2",
      "4"
    ],
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "num_stream": {
    "availability": "",
    "default": "\"4\"",
    "description": "The number of streams used in GPU calculations (only for LCAO). For most devices, the performance is satisfactory when the number is larger than 2.",
    "exclusiveMinimum": 2.0,
    "mdType": "int",
    "section": "Numerical atomic orbitals related variables",
    "type": "integer",
    "unit": ""
  },
  "nupdown": {
    "availability": "",
    "default": "0.0",
    "description": "- 0.0: no constrain apply to system.\n  - `>0.0`: The different number of electrons between spin-up and spin-down channels. The range of value must be in [-nelec ~ nelec]. It is one type of constrainted DFT method, two Fermi energies will be calculated.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "nvirt (Under Development Feature)": {
    "availability": "",
    "default": "1",
    "description": "The number of virtual orbitals (staring from LUMO) used in the LR-TDDFT calculation.",
    "mdType": "Integer",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "integer",
    "unit": ""
  },
  "nx": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "ny": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "nz": {
    "availability": "",
    "default": "0",
    "description": "If set to a positive number, then the three variables specify the numbers of FFT grid points in x, y, z directions, respectively. If set to 0, the number will be calculated from ecutrho.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "ocp": {
    "availability": "- For PW and LCAO codes: If enabled, the band occupations will be determined by `ocp_set`.\n  - For RT-TDDFT in LCAO codes: If enabled, same as above, but the occupations will be constrained starting from the second ionic step.\n  - For OFDFT: This feature is not available.",
    "default": "False",
    "description": "- True: Fixes the band occupations based on the values specified in `ocp_set`.\n- False: Does not fix the band occupations.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "ocp_set": {
    "availability": "",
    "default": "None",
    "dependencies": {
      "ocp": true
    },
    "description": "- If `ocp` is set to 1, `ocp_set` must be provided as a string specifying the occupation numbers for each band across all k-points. The format follows a space-separated pattern, where occupations are assigned sequentially to bands for each k-point. A shorthand notation `N*x` can be used to repeat a value `x` for `N` bands.\n  - Example:\n    - `1 10*1 0 1` represents occupations for 13 bands, where the 12th band is fully unoccupied (`0`), and all others are occupied (`1`).\n    - For a system with multiple k-points, the occupations must be specified for all k-points, following their order in the output file kpoints (may lead to fractional occupations).\n  - Incorrect specification of `ocp_set` could lead to inconsistencies in electron counting, causing the calculation to terminate with an error.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "of_cd": {
    "availability": "TDOFDFT",
    "default": "False",
    "description": "Added the current dependent(CD) potential. (https://doi.org/10.1103/PhysRevB.98.144302)\n  - True: Added the CD potential.\n  - False: Not added the CD potential.",
    "mdType": "Boolean\nBoolean",
    "section": "TDOFDFT: time dependent orbital free density functional theory",
    "type": "string",
    "unit": ""
  },
  "of_conv": {
    "availability": "OFDFT",
    "default": "energy",
    "description": "Criterion used to check the convergence of OFDFT.",
    "mdType": "String",
    "section": "OFDFT: orbital free density functional theory",
    "type": "string",
    "unit": ""
  },
  "of_full_pw": {
    "availability": "OFDFT",
    "default": "True",
    "description": "Whether to use full planewaves.",
    "mdType": "Boolean",
    "section": "OFDFT: orbital free density functional theory",
    "type": "boolean",
    "unit": ""
  },
  "of_full_pw_dim": {
    "availability": "OFDFT with `of_full_pw = True`",
    "default": "0",
    "description": "Specify the parity of FFT dimensions.",
    "mdType": "Integer",
    "section": "OFDFT: orbital free density functional theory",
    "type": "integer",
    "unit": ""
  },
  "of_hold_rho0": {
    "availability": "OFDFT with `of_kinetic=wt`",
    "default": "False",
    "description": "Whether to fix the average density rho0.",
    "mdType": "Boolean",
    "section": "OFDFT: orbital free density functional theory",
    "type": "boolean",
    "unit": ""
  },
  "of_kernel_file": {
    "availability": "OFDFT with `of_read_kernel=True`",
    "default": "WTkernel.txt",
    "description": "The name of WT kernel file.",
    "mdType": "String",
    "section": "OFDFT: orbital free density functional theory",
    "type": "string",
    "unit": ""
  },
  "of_kinetic": {
    "availability": "OFDFT",
    "default": "wt",
    "description": "The type of KEDF (kinetic energy density functional).\n\n  Analytical functionals:",
    "mdType": "String",
    "section": "OFDFT: orbital free density functional theory",
    "type": "string",
    "unit": ""
  },
  "of_lkt_a": {
    "availability": "OFDFT with `of_kinetic=lkt`",
    "default": "1.3",
    "description": "Parameter a of LKT KEDF (kinetic energy density functional).",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_mcd_alpha": {
    "availability": "TDOFDFT",
    "default": "1.0",
    "description": "The value of the parameter alpha in modified CD potential method. mCDPotenial=alpha*CDPotenial(proposed in paper PhysRevB.98.144302)",
    "mdType": "Real",
    "section": "TDOFDFT: time dependent orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_method": {
    "availability": "OFDFT",
    "default": "tn",
    "description": "The optimization method used in OFDFT.",
    "mdType": "String",
    "section": "OFDFT: orbital free density functional theory",
    "type": "string",
    "unit": ""
  },
  "of_ml_chi_p": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Hyperparameter $\\chi_p$: $\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))$.",
    "mdType": "Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "number",
    "unit": ""
  },
  "of_ml_chi_pnl": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the hyperparameter $\\chi_{p_{\\rm{nl}}}$ of non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}$.",
    "mdType": "Vector of Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_chi_q": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Hyperparameter $\\chi_q$: $\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))$.",
    "mdType": "Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "number",
    "unit": ""
  },
  "of_ml_chi_qnl": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the hyperparameter $\\chi_{q_{\\rm{nl}}}$ of non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}$.",
    "mdType": "Vector of Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_chi_xi": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the hyperparameter $\\chi_\\xi$ of non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))$.",
    "mdType": "Vector of Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_device": {
    "availability": "OFDFT",
    "default": "cpu",
    "description": "Run Neural Network on GPU or CPU.",
    "mdType": "String",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_feg": {
    "availability": "OFDFT",
    "default": "0",
    "description": "The method to incorporate the Free Electron Gas (FEG) limit: $F_\\theta |_{\\rm{FEG}} = 1$, where $F_\\theta$ is enhancement factor of Pauli energy.",
    "mdType": "Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "integer",
    "unit": ""
  },
  "of_ml_gamma": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Local descriptor: $\\gamma(\\mathbf{r}) = (\\rho(\\mathbf{r}) / \\rho_0)^{1/3}$.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_gammanl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\gamma_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\gamma(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_gene_data": {
    "availability": "Used only for KSDFT with plane wave basis",
    "default": "False",
    "description": "Controls the generation of machine learning training data. When enabled, training data in `.npy` format will be saved in the directory `OUT.${suffix}/MLKEDF_Descriptors/`. The generated descriptors are categorized as follows:\n  - Local/Semilocal Descriptors. Files are named as `{var}.npy`, where `{var}` corresponds to the descriptor type:\n    - `gamma`: Enabled by [of_ml_gamma](#of_ml_gamma)\n    - `p`: Enabled by [of_ml_p](#of_ml_p)\n    - `q`: Enabled by [of_ml_q](#of_ml_q)\n    - `tanhp`: Enabled by [of_ml_tanhp](#of_ml_tanhp)\n    - `tanhq`: Enabled by [of_ml_tanhq](#of_ml_tanhq)\n  - Nonlocal Descriptors generated using kernels configured via [of_ml_nkernel](#of_ml_nkernel), [of_ml_kernel](#of_ml_kernel), and [of_ml_kernel_scaling](#of_ml_kernel_scaling). Files follow the naming convention `{var}_{kernel_type}_{kernel_scaling}.npy`, where `{kernel_type}` and `{kernel_scaling}` are specified by [of_ml_kernel](#of_ml_kernel), and [of_ml_kernel_scaling](#of_ml_kernel_scaling), respectively, and `{val}` denotes the kind of the descriptor, including\n      - `gammanl`: Enabled by [of_ml_gammanl](#of_ml_gammanl)\n      - `pnl`: Enabled by [of_ml_pnl](#of_ml_pnl)\n      - `qnl`: Enabled by [of_ml_qnl](#of_ml_qnl)\n      - `xi`: Enabled by [of_ml_xi](#of_ml_xi)\n      - `tanhxi`: Enabled by [of_ml_tanhxi](#of_ml_tanhxi)\n      - `tanhxi_nl`: Enabled by [of_ml_tanhxi_nl](#of_ml_tanhxi_nl)\n      - `tanh_pnl`: Enabled by [of_ml_tanh_pnl](#of_ml_tanh_pnl)\n      - `tanh_qnl`: Enabled by [of_ml_tanh_qnl](#of_ml_tanh_qnl)\n      - `tanhp_nl`: Enabled by [of_ml_tanhp_nl](#of_ml_tanhp_nl)\n      - `tanhq_nl`: Enabled by [of_ml_tanhq_nl](#of_ml_tanhq_nl)\n  - Training Targets, including key quantum mechanical quantities:\n    - `enhancement.npy`: Pauli energy enhancement factor $T_\\theta/T_{\\rm{TF}}$, where $T_{\\rm{TF}}$ is the Thomas-Fermi functional\n    - `pauli.npy`: Pauli potential $V_\\theta$\n    - `veff.npy`: Effective potential",
    "enum": [
      "gamma",
      "p",
      "q",
      "tanhp",
      "tanhq",
      "gammanl",
      "pnl",
      "qnl",
      "xi",
      "tanhxi",
      "tanhxi_nl",
      "tanh_pnl",
      "tanh_qnl",
      "tanhp_nl",
      "tanhq_nl"
    ],
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_kernel": {
    "availability": "OFDFT",
    "default": "1",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the type of the $i$-th kernel function.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_kernel_file": {
    "availability": "OFDFT",
    "default": "none",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the file containint the $i$-th kernel function. ONLY used for TKK.",
    "mdType": "Vector of String",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_kernel_scaling": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the RECIPROCAL of scaling parameter $\\lambda$ of the $i$-th kernel function. $w_i(\\mathbf{r}-\\mathbf{r}') = \\lambda^3 w_i'(\\lambda(\\mathbf{r}-\\mathbf{r}'))$.",
    "mdType": "Vector of Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_local_test": {
    "availability": "OFDFT",
    "default": "False",
    "description": "FOR TEST. Read in the density, and output the F and Pauli potential.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_nkernel": {
    "availability": "OFDFT",
    "default": "1",
    "description": "Number of kernel functions.",
    "mdType": "Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "integer",
    "unit": ""
  },
  "of_ml_p": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Semi-local descriptor: $p(\\mathbf{r}) = \\frac{|\\nabla \\rho(\\mathbf{r})|^2} {[2 (3 \\pi^2)^{1/3} \\rho^{4/3}(\\mathbf{r})]^2}$.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_pnl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $p_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') p(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_q": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Semi-local descriptor: $q(\\mathbf{r}) = \\frac{\\nabla^2 \\rho(\\mathbf{r})} {[4 (3 \\pi^2)^{2/3} \\rho^{5/3}(\\mathbf{r})]}$.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_qnl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $q_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') q(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanh_pnl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{p_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{p_{\\rm{nl}}} p_{\\rm{nl}}(\\mathbf{r}))}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanh_qnl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{q_{\\rm{nl}}}(\\mathbf{r}) = \\tanh{(\\chi_{q_{\\rm{nl}}} q_{\\rm{nl}}(\\mathbf{r}))}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanhp": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Semi-local descriptor: $\\tilde{p}(\\mathbf{r}) = \\tanh(\\chi_p p(\\mathbf{r}))$.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_tanhp_nl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{p}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{p}(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanhq": {
    "availability": "OFDFT",
    "default": "False",
    "description": "Semi-local descriptor: $\\tilde{q}(\\mathbf{r}) = \\tanh(\\chi_q q(\\mathbf{r}))$.",
    "mdType": "Boolean",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "boolean",
    "unit": ""
  },
  "of_ml_tanhq_nl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{q}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{q}(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanhxi": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{\\xi}(\\mathbf{r}) = \\tanh(\\chi_{\\xi} \\xi(\\mathbf{r}))$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_tanhxi_nl": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\tilde{\\xi}_{\\rm{nl}}(\\mathbf{r}) = \\int{w_i(\\mathbf{r}-\\mathbf{r}') \\tilde{\\xi}(\\mathbf{r}') dr'}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_xi": {
    "availability": "OFDFT",
    "default": "0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element controls the non-local descriptor defined by the $i$-th kernel function $w_i(\\mathbf{r}-\\mathbf{r}')$: $\\xi(\\mathbf{r}) = \\frac{\\int{w_i(\\mathbf{r}-\\mathbf{r}') \\rho^{1/3}(\\mathbf{r}') dr'}}{\\rho^{1/3}(\\mathbf{r})}$.",
    "mdType": "Vector of Integer",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_ml_yukawa_alpha": {
    "availability": "OFDFT",
    "default": "1.0",
    "description": "Containing nkernel (see [of_ml_nkernel](#of_ml_nkernel)) elements. The $i$-th element specifies the parameter $\\alpha$ of $i$-th kernel function. ONLY used for Yukawa kernel function.",
    "mdType": "Vector of Real",
    "section": "ML-KEDF: machine learning based kinetic energy density functional for OFDFT",
    "type": "string",
    "unit": ""
  },
  "of_read_kernel": {
    "availability": "OFDFT with `of_kinetic=wt`",
    "default": "False",
    "description": "Whether to read in the kernel file.",
    "mdType": "Boolean",
    "section": "OFDFT: orbital free density functional theory",
    "type": "boolean",
    "unit": ""
  },
  "of_tf_weight": {
    "availability": "OFDFT with `of_kinetic=tf, tf+, wt, xwm`",
    "default": "1.0",
    "description": "Weight of TF KEDF (kinetic energy density functional).",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_tole": {
    "availability": "OFDFT",
    "default": "2e-6",
    "description": "Tolerance of the energy change for determining the convergence.",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": "Ry"
  },
  "of_tolp": {
    "availability": "OFDFT",
    "default": "1e-5",
    "description": "Tolerance of potential for determining the convergence.",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": "Ry"
  },
  "of_vw_weight": {
    "availability": "OFDFT with `of_kinetic=vw, tf+, wt, lkt, xwm`",
    "default": "1.0",
    "description": "Weight of vW KEDF (kinetic energy density functional).",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_wt_alpha": {
    "availability": "OFDFT with `of_kinetic=wt`",
    "default": "$5/6$",
    "description": "Parameter alpha of WT KEDF (kinetic energy density functional).",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_wt_beta": {
    "availability": "OFDFT with `of_kinetic=wt`",
    "default": "$5/6$",
    "description": "Parameter beta of WT KEDF (kinetic energy density functional).",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_wt_rho0": {
    "availability": "OFDFT with `of_kinetic=wt`",
    "default": "0.0",
    "description": "The average density of system.",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": "Bohr^-3"
  },
  "of_xwm_kappa": {
    "availability": "OFDFT with `of_kinetic=xwm`",
    "default": "0.0",
    "description": "Parameter $\\kappa$ for XWM kinetic energy functional. See PHYSICAL REVIEW B 100, 205132 (2019) for optimal values.",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "of_xwm_rho_ref": {
    "availability": "OFDFT with `of_kinetic=xwm`",
    "default": "0.0",
    "description": "Reference charge density for XWM kinetic energy functional. If set to 0, the program will use average charge density.",
    "mdType": "Real",
    "section": "OFDFT: orbital free density functional theory",
    "type": "number",
    "unit": ""
  },
  "omc": {
    "availability": "",
    "default": "0",
    "description": "The parameter controls the form of occupation matrix control used.\n  - 0: No occupation matrix control is performed, and the onsite density matrix will be calculated from wavefunctions in each SCF step.\n  - 1: The first SCF step will use an initial density matrix read from a file named `[initial_onsite.dm](http://initial_onsite.dm/)`, but for later steps, the onsite density matrix will be updated.\n  - 2: The same onsite density matrix from `initial_onsite.dm` will be used throughout the entire calculation.\n\n> Note : The easiest way to create `initial_onsite.dm` is to run a DFT+U calculation, look for a file named `onsite.dm` in the OUT.prefix directory, and make replacements there. The format of the file is rather straight-forward.",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "DFT+*U* correction",
    "type": "integer",
    "unit": ""
  },
  "onsite_radius": {
    "availability": "`dft_plus_u` is set to 1",
    "default": "3.0",
    "description": "- The `Onsite-radius` parameter facilitates modulation of the single-zeta portion of numerical atomic orbitals for projections for DFT+U.\n  - The modulation algorithm includes a smooth truncation applied directly to the tail of the original orbital, followed by normalization.  Consider the function:\n  $$\n  g(r;\\sigma)=\\begin{cases}\n  1-\\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right), & r < r_c\\\\\n  0, & r \\geq r_c\n  \\end{cases}\n  $$\n  - where $\\sigma$ is a parameter that controls the smoothing interval. A normalized function truncated smoothly at $r_c$ can be represented as:\n\n  $$\n  \\alpha(r) = \\frac{\\chi(r)g(r;\\sigma)}{\\langle\\chi(r)g(r;\\sigma), \\chi(r)g(r;\\sigma)\\rangle}\n  $$\n\n  - To find an appropriate $\\sigma$, the optimization process is as follows:\n\n  - Maximizing the overlap integral under a normalization constraint is equivalent to minimizing an error function:\n\n  $$\n  \\min \\langle \\chi(r)-\\alpha(r), \\chi(r)-\\alpha(r)\\rangle \\quad \\text{subject to} \\quad \\langle \\alpha(r),\\alpha(r)\\rangle=1\n  $$\n\n  - Similar to the process of generating numerical atomic orbitals, this optimization choice often induces additional oscillations in the outcome. To suppress these oscillations, we may include a derivative term in the objective function ($f'(r)\\equiv \\mathrm{d}f(r)/\\mathrm{d}r$):\n\n  $$\n  \\min \\left[\\gamma\\langle \\chi(r)-\\alpha(r), \\chi(r)-\\alpha(r)\\rangle + \\langle \\chi'(r)-\\alpha'(r), \\chi'(r)-\\alpha'(r)\\rangle\\right] \\quad \\text{subject to} \\quad \\langle \\alpha(r),\\alpha(r)\\rangle=1\n  $$\n\n  - where $\\gamma$ is a parameter that adjusts the relative weight of the error function to the derivative error function.",
    "mdType": "Real",
    "section": "DFT+*U* correction",
    "type": "number",
    "unit": "Bohr"
  },
  "orbital_corr": {
    "availability": "",
    "default": "-1",
    "description": "Specifies which orbits need plus U correction for each atom type ($l_1,l_2,l_3,\\ldots$ for atom type 1, 2, 3, respectively).\n  - -1: The plus U correction will not be calculated for this atom.\n  - 1: For p-electron orbits, the plus U correction is needed.\n  - 2: For d-electron orbits, the plus U correction is needed.\n  - 3: For f-electron orbits, the plus U correction is needed.",
    "enum": [
      "-1",
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "DFT+*U* correction",
    "type": "integer",
    "unit": ""
  },
  "orbital_dir": {
    "availability": "",
    "default": "\"\"",
    "description": "The directory to save numerical atomic orbitals.\n  - This parameter is combined with orbital filenames in the STRU file to form the complete orbital file paths.\n  - Example: set orbital_dir to \"../\" with \"Si.orb\" which specified under \"NUMERICAL_ORBITAL\" in STRU file, ABACUS will open the orbital file in path \"../Si.orb\".",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "out_alllog": {
    "availability": "",
    "default": "False",
    "description": "Whether to print information into individual logs from all ranks in an MPI run.\n  - True: Information from each rank will be written into individual files named `OUT.${suffix}/running_${calculation}_${rank+1}.log`.\n  - False: Information will only be written from rank 0 into a file named `OUT.${suffix}/running_${calculation}.log`.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_app_flag": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "true",
    "description": "Whether to output $r(R)$, $H(R)$, $S(R)$, $T(R)$, $dH(R)$, $H(k)$, $S(k)$ and $wfc(k)$ matrices in an append manner during molecular dynamics calculations. Check input parameters [out_mat_r](#out_mat_r), [out_mat_hs2](#out_mat_hs2), [out_mat_t](#out_mat_t), [out_mat_dh](#out_mat_dh), [out_mat_hs](#out_mat_hs) and [out_wfc_lcao](#out_wfc_lcao) for more information.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_band": {
    "availability": "",
    "default": "False",
    "description": "Whether to output the eigenvalues of the Hamiltonian matrix (in eV) into the running log during electronic iterations and into a file at the end of calculations. The former can be used with the 'out_freq_elec' parameter while the latter option allows the output precision to be set via a second parameter, with a default value of 8. The output file names are:\n    - nspin = 1 or 4: `eig.txt`;\n    - nspin = 2: `eigs1.txt` and `eigs2.txt`;\n    - For more information, refer to the [band.md](../elec_properties/band.md)",
    "mdType": "Boolean \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_chg": {
    "availability": "",
    "default": "0 3",
    "description": "The first integer controls whether to output the charge density on real space grids:\n  - 1: Output the charge density (in Bohr^-3) on real space grids into the density files in the folder `OUT.${suffix}`. The files are named as:\n    - nspin = 1: `chg.cube`;\n    - nspin = 2: `chgs1.cube`, and `chgs2.cube`;\n    - nspin = 4: `chgs1.cube`, `chgs2.cube`, `chgs3.cube`, and `chgs4.cube`;\n  Note that by using the Meta-GGA functional, additional files containing the kinetic energy density will be output with the following names:\n    - nspin = 1: `tau.cube`;\n    - nspin = 2: `taus1.cube`, and `taus2.cube`;\n    - nspin = 4: `taus1.cube`, `taus2.cube`, `taus3.cube`, and `taus4.cube`;\n  - 2: On top of 1, also output the initial charge density files with a suffix name as '_ini', such as `taus1_ini.cube`, etc.\n  - -1: disable the charge density auto-back-up file `{suffix}-CHARGE-DENSITY.restart`, useful for large systems.\n\n  The second integer controls the precision of the charge density output, if not given, will use `3` as default. For purpose restarting from this file and other high-precision involved calculation, recommend to use `10`.\n\n  ---\n  The circle order of the charge density on real space grids is: x is the outer loop, then y and finally z (z is moving fastest).\n\n  In EXX(exact exchange) calculations, (i.e. *[dft_fuctional](#dft_functional)==hse/hf/pbe0/scan0* or *[rpa](#rpa)==True*), the Hexx(R) files will be output in the folder `OUT.${suffix}` too, which can be read in NSCF calculation.\n\n  In molecular dynamics simulations, the output frequency is controlled by [out_freq_ion](#out_freq_ion).",
    "enum": [
      "0",
      "1",
      "2",
      "-1"
    ],
    "mdType": "Integer \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_current": {
    "availability": "",
    "default": "0",
    "description": "- 0: Do not output current.\n  - 1: Output current using the two-center integral, faster.\n  - 2: Output current using the matrix commutation, more precise.",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "out_current_k": {
    "availability": "",
    "default": "False",
    "description": "- True: Output current for each k-points separately.\n  - False: Output current in total.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "out_dipole": {
    "availability": "",
    "default": "False",
    "description": "- True: Output electric dipole moment.\n  - False: Do not output electric dipole moment.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "out_dmk": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Whether to output the density matrix for each k-point into files in the folder `OUT.${suffix}`. The files are named as:\n  - For gamma only case:\n    - nspin = 1 and 4: `dm_nao.csr`;\n    - nspin = 2: `dms1_nao.csr` and `dms2_nao.csr` for the two spin channels.\n  - For multi-k points case:\n    - nspin = 1 and 4: `dmk1_nao.csr`, `dmk2_nao.csr`, ...;\n    - nspin = 2: `dmk1s1_nao.csr`... and `dmk1s2_nao.csr`... for the two spin channels.",
    "mdType": "Boolean \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_dmr": {
    "availability": "Numerical atomic orbital basis (multi-k points)",
    "default": "False",
    "description": "Whether to output the density matrix with Bravias lattice vector R index into files in the folder `OUT.${suffix}`. The files are named as `dmr{s}{spin index}{g}{geometry index}{_nao} + {\".csr\"}`. Here, 's' refers to spin, where s1 means spin up channel while s2 means spin down channel, and the sparse matrix format 'csr' is mentioned in [out_mat_hs2](#out_mat_hs2). Finally, if [out_app_flag](#out_app_flag) is set to false, the file name contains the optional 'g' index for each ionic step that may have different geometries, and if [out_app_flag](#out_app_flag) is set to true, the density matrix with respect to Bravias lattice vector R accumulates during ionic steps:\n  - nspin = 1: `dmrs1_nao.csr`;\n  - nspin = 2: `dmrs1_nao.csr` and `dmrs2_nao.csr` for the two spin channels.",
    "mdType": "Boolean \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_dos": {
    "availability": "",
    "default": "0",
    "description": "Whether to output the density of states (DOS). For more information, refer to the [dos.md](../elec_properties/dos.md).\n  - 0: no output\n  - 1: output the density of states (DOS)\n    - nspin=1 or 4: `doss1g{geom}_{basis}.txt`, where geom is the geometry index when cell changes or ions move while basis is either `pw` or `nao`.\n    - nspin=2: `doss1g{geom}_{basis}.txt` and `doss2g{geom}_{basis}.txt` for two spin channles.\n  - 2: (LCAO) output the density of states (DOS) and the projected density of states (PDOS)\n  - 3: output the Fermi surface file (fermi.bxsf) in BXSF format that can be visualized by XCrySDen",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_eband_terms": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Whether to print the band energy terms separately in the file `OUT.${suffix}/${term}_out.dat`. The terms include the kinetic, pseudopotential (local + nonlocal), Hartree and exchange-correlation (including exact exchange if calculated).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_efield": {
    "availability": "",
    "default": "False",
    "description": "Whether to output the electric field data to files. When enabled, writes real-time electric field values (unit: ​​V/Å​​) into files named `efield_[num].txt`, where `[num]` is the ​​sequential index of the electric field ranges from `0` to `N-1` for `N` configured fields. It is noteworthy that the field type sequence follows [`td_ttype`](#td_ttype), while the direction sequence follows [`td_vext_dire`](#td_vext_dire).\n  - True: Output electric field.\n  - False: Do not output electric field.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "out_element_info": {
    "availability": "",
    "default": "False",
    "description": "Whether to print element information into files in the directory `OUT.${suffix}/${element_label}`, including pseudopotential and orbital information of the element (in atomic Ryberg units).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_elf": {
    "availability": "Only for Kohn-Sham DFT and Orbital Free DFT.",
    "default": "0 3",
    "description": "Whether to output the electron localization function (ELF) in the folder `OUT.${suffix}`. The files are named as\n    - nspin = 1:\n      - elf.cube: ${\\rm{ELF}} = \\frac{1}{1+\\chi^2}$, $\\chi = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i}|^2} - \\frac{|\\nabla\\rho|^2}{8\\rho}}{\\frac{3}{10}(3\\pi^2)^{2/3}\\rho^{5/3}}$;\n    - nspin = 2:\n      - elf1.cube, elf2.cube: ${\\rm{ELF}}_\\sigma = \\frac{1}{1+\\chi_\\sigma^2}$, $\\chi_\\sigma = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i,\\sigma}|^2} - \\frac{|\\nabla\\rho_\\sigma|^2}{8\\rho_\\sigma}}{\\frac{3}{10}(6\\pi^2)^{2/3}\\rho_\\sigma^{5/3}}$;\n      - elf.cube: ${\\rm{ELF}} = \\frac{1}{1+\\chi^2}$, $\\chi = \\frac{\\frac{1}{2}\\sum_{i,\\sigma}{f_i |\\nabla\\psi_{i,\\sigma}|^2} - \\sum_{\\sigma}{\\frac{|\\nabla\\rho_\\sigma|^2}{8\\rho_\\sigma}}}{\\sum_{\\sigma}{\\frac{3}{10}(6\\pi^2)^{2/3}\\rho_\\sigma^{5/3}}}$;\n    - nspin = 4 (noncollinear):\n      - elf.cube: ELF for total charge density, ${\\rm{ELF}} = \\frac{1}{1+\\chi^2}$, $\\chi = \\frac{\\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i}|^2} - \\frac{|\\nabla\\rho|^2}{8\\rho}}{\\frac{3}{10}(3\\pi^2)^{2/3}\\rho^{5/3}}$\n\n  The second integer controls the precision of the kinetic energy density output, if not given, will use `3` as default. For purpose restarting from this file and other high-precision involved calculation, recommend to use `10`.\n\n  ---\n  In molecular dynamics calculations, the output frequency is controlled by [out_freq_ion](#out_freq_ion).",
    "mdType": "Integer \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_freq_elec": {
    "availability": "",
    "default": "[`scf_nmax`](#scf_nmax)",
    "description": "Output the charge density (only binary format, controlled by [`out_chg`](#out_chg)), wavefunction (controlled by [`out_wfc_pw`](#out_wfc_pw)) per `out_freq_elec` electronic iterations. Note that they are always output when converged or reach the maximum iterations [`scf_nmax`](#scf_nmax).",
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_freq_ion": {
    "availability": "",
    "default": "0",
    "description": "Controls the output interval in **ionic steps**. When set to a positive integer $N$, information such as charge density, local potential, electrostatic potential, Hamiltonian matrix, overlap matrix, density matrix, and Mulliken population analysis is printed every $N$ ionic steps.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_freq_td": {
    "availability": "",
    "default": "0",
    "description": "Controls the output interval in **completed electronic evolution steps** during RT-TDDFT calculations. When set to a positive integer $N$, detailed information (see [`out_freq_ion`](#out_freq_ion)) is printed every $N$ electron time-evolution steps (i.e., every $N$ `STEP OF ELECTRON EVOLVE`). For example, if you wish to output information once per ionic step, you should set `out_freq_td` equal to [`estep_per_md`](#estep_per_md), since one ionic step corresponds to [`estep_per_md`](#estep_per_md) electronic evolution steps.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_ldos": {
    "availability": "",
    "default": "0",
    "description": "Whether to output the local density of states (LDOS), optionally output precision can be set by a second parameter, default is 3.\n  - 0: no output\n  - 1: output the partial charge density for given bias (controlled by [stm_bias](#stm_bias)) in cube file format, which can be used to plot scanning tunneling spectroscopys to mimick STM images using the Python script [plot.py](../../../tools/stm/plot.py).\n  - 2: output LDOS along a line in real space (controlled by [ldos_line](#ldos_line)). Parameters used to control DOS output are also valid for LDOS.\n  - 3: output both two LDOS modes above.",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_level": {
    "availability": "",
    "default": "ie",
    "description": "Control the output level of information in `OUT.${suffix}/running_${calculation}.log`.\n  - ie: electronic iteration level, which prints useful information for electronic iterations;\n  - i: geometry relaxation level, which prints some information for geometry relaxations additionally;\n  - m: molecular dynamics level, which does not print some information for simplicity.",
    "enum": [
      "ie",
      "i",
      "m"
    ],
    "mdType": "String",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_mat_dh": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "False",
    "description": "Whether to print files containing the derivatives of the Hamiltonian matrix. The format will be the same as the Hamiltonian matrix $H(R)$ and overlap matrix $S(R)$ as mentioned in [out_mat_hs2](#out_mat_hs2). The name of the files will be `dhrxs1_nao.csr`, `dhrys1_nao.csr`, `dhrzs1_nao.csr` and so on. Also controled by [out_freq_ion](#out_freq_ion) and [out_app_flag](#out_app_flag).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry/Bohr"
  },
  "out_mat_ds": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "False",
    "description": "Whether to print files containing the derivatives of the overlap matrix. The format will be the same as the overlap matrix $dH(R)$ as mentioned in [out_mat_dh](#out_mat_dh). The name of the files will be `dsrxs1.csr` and so on. Also controled by [out_freq_ion](#out_freq_ion) and [out_app_flag](#out_app_flag). This feature can be used with `calculation get_s`.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry/Bohr"
  },
  "out_mat_hs": {
    "availability": "Numerical atomic orbital basis",
    "default": "False 8",
    "description": "Whether to print the upper triangular part of the Hamiltonian matrices and overlap matrices for each k-point into files in the directory `OUT.${suffix}`. The second number controls precision. For more information, please refer to [hs_matrix.md](../elec_properties/hs_matrix.md#out_mat_hs). Also controled by [out_freq_ion](#out_freq_ion) and [out_app_flag](#out_app_flag).\n  - For gamma only case:\n    - nspin = 1: `hks1_nao.txt` for the Hamiltonian matrix and `sks1_nao.txt` for the overlap matrix;\n    - nspin = 2: `hks1_nao.txt` and `hks2_nao.txt` for the Hamiltonian matrix and `sks1_nao.txt` for the overlap matrix. Note that the code will not output `sks2_nao.txt` because it is the same as `sks1_nao.txt`;\n    - nspin = 4: `hks12_nao.txt` for the Hamiltonian matrix and `sks12_nao.txt` for the overlap matrix.\n  - For multi-k points case:\n    - nspin = 1: `hks1k1_nao.txt` for the Hamiltonian matrix at the 1st k-point, and `sks1k1_nao.txt` for the overlap matrix for the 1st k-point, ...;\n    - nspin = 2: `hks1k1_nao.txt` and `hks2k1_nao.txt` for the two spin channels of the Hamiltonian matrix at the 1st k-point, and `sks1k1_nao.txt` for the overlap matrix for the 1st k-point. Note that the code will not output `sks2k1_nao.txt` because it is the same as `sks1k1_nao.txt`, ...;\n    - nspin = 4: `hks12k1_nao.txt` for the Hamiltonian matrix at the 1st k-point, and `sks12k1_nao.txt` for the overlap matrix for the 1st k-point, ...;",
    "mdType": "Boolean \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": "Ry"
  },
  "out_mat_hs2": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "False",
    "description": "Whether to print files containing the Hamiltonian matrix $H(R)$ and overlap matrix $S(R)$ into files in the directory `OUT.${suffix}`. For more information, please refer to [hs_matrix.md](../elec_properties/hs_matrix.md#out_mat_hs2).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry"
  },
  "out_mat_l": {
    "availability": "Numerical atomic orbital (NAO) basis",
    "default": "False 8",
    "description": "Whether to print the expectation value of the angular momentum operator $\\hat{L}_x$, $\\hat{L}_y$, and $\\hat{L}_z$ in the basis of the localized atomic orbitals. The files are named `OUT.${suffix}/${suffix}_Lx.dat`, `OUT.${suffix}/${suffix}_Ly.dat`, and `OUT.${suffix}/${suffix}_Lz.dat`. The second integer controls the precision of the output.",
    "mdType": "Boolean [Integer\\](optional)",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_mat_r": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "False",
    "description": "Whether to print the matrix representation of the position matrix into a file named `rr.csr` in the directory `OUT.${suffix}`. If [calculation](#calculation) is set to `get_s`, the position matrix can be obtained without scf iterations. For more information, please refer to [position_matrix.md](../elec_properties/position_matrix.md#extracting-position-matrices).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Bohr"
  },
  "out_mat_t": {
    "availability": "Numerical atomic orbital basis (not gamma-only algorithm)",
    "default": "False",
    "description": "Generate files containing the kinetic energy matrix $T(R)$. The format will be the same as the Hamiltonian matrix $H(R)$ and overlap matrix $S(R)$ as mentioned in [out_mat_hs2](#out_mat_hs2). The name of the files will be `trs1_nao.csr` and so on. Also controled by [out_freq_ion](#out_freq_ion) and [out_app_flag](#out_app_flag).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry"
  },
  "out_mat_tk": {
    "availability": "Numerical atomic orbital basis",
    "default": "False \\[8\\]",
    "description": "Whether to print the upper triangular part of the kinetic matrices for each k-point into `OUT.${suffix}/tks1ki_nao.txt`, where i is the index of k points. One may optionally provide a second parameter to specify the precision.",
    "mdType": "Boolean \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": "Ry"
  },
  "out_mat_xc": {
    "availability": "Numerical atomic orbital (NAO) and NAO-in-PW basis",
    "default": "False",
    "description": "Whether to print the upper triangular part of the exchange-correlation matrices in Kohn-Sham orbital representation: $\\braket{\\psi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\psi_j}$ for each k point into files in the directory `OUT.${suffix}`, which is useful for the subsequent GW calculation (the code is still under development). (Note that currently DeePKS term is not included.) The files are named `vxcs1k$i_nao.txt`, where `$i` corresponds to the k point index. The band (KS orbital) energy for each (k-point, spin, band) will be printed in the file `OUT.${suffix}/vxc_out.dat`. If EXX is calculated, the local and EXX part of band energy will also be printed in `OUT.${suffix}/vxc_local_out.dat`and `OUT.${suffix}/vxc_exx_out.dat`, respectively. All the `vxc*_out.dat` files contains 3 integers (nk, nspin, nband) followed by nk\\*nspin\\*nband lines of energy Hartree and eV.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry"
  },
  "out_mat_xc2": {
    "availability": "Numerical atomic orbital (NAO) basis",
    "default": "False",
    "description": "Whether to print the exchange-correlation matrices in numerical orbital representation: $\\braket{\\phi_i|V_\\text{xc}^\\text{(semi-)local}+V_\\text{exx}+V_\\text{DFTU}|\\phi_j}(\\mathbf{R})$ in CSR format in the directory `OUT.${suffix}`. (Note that currently DeePKS term is not included. ) The files are named `Vxc_R_spin$s`.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": "Ry"
  },
  "out_mul": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Whether to print the Mulliken population analysis result into `OUT.${suffix}/mulliken.txt`. In molecular dynamics calculations, the output frequency is controlled by [out_freq_ion](#out_freq_ion).",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_ndigits": {
    "availability": "`out_mat_hs 1` case presently.",
    "default": "8",
    "description": "Controls the length of decimal part of output data, such as charge density, Hamiltonian matrix, Overlap matrix and so on.",
    "mdType": "Integar",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_pchg": {
    "availability": "For both PW and LCAO. When `basis_type = lcao`, used when `calculation = get_pchg`.",
    "default": "none",
    "dependencies": {
      "basis_type": "lcao"
    },
    "description": "Specifies the electronic states to calculate the charge densities $|\\psi_{i}(\\boldsymbol{r})|^{2}$ with state index $i$ for, using a space-separated string of 0s and 1s. Each digit in the string corresponds to a state, starting from the first state. A `1` indicates that the charge density should be calculated for that state, while a `0` means the state will be ignored. The parameter allows a compact and flexible notation (similar to [`ocp_set`](#ocp_set)), for example the syntax `1 4*0 5*1 0` is used to denote the selection of states: `1` means calculate for the first state, `4*0` skips the next four states, `5*1` means calculate for the following five states, and the final `0` skips the next state. It's essential that the total count of states does not exceed the total number of states (`nbands`); otherwise, it results in an error, and the process exits. The input string must contain only numbers and the asterisk (`*`) for repetition, ensuring correct format and intention of state selection. The outputs comprise multiple `.cube` files following the naming convention `pchgi[state]s[spin]k[kpoint].cube`.",
    "mdType": "String",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_pot": {
    "availability": "",
    "default": "0",
    "description": "- 1: Output the **total local potential** (i.e., local pseudopotential + Hartree potential + XC potential + external electric field (if exists) + dipole correction potential (if exists) + ...) on real space grids (in Ry) into files in the folder `OUT.${suffix}`. The files are named as:\n    - nspin = 1: `pots1.cube`;\n    - nspin = 2: `pots1.cube` and `pots2.cube`;\n    - nspin = 4: `pots1.cube`, `pots2.cube`, `pots3.cube`, and `pots4.cube`\n  - 2: Output the **electrostatic potential** on real space grids into `OUT.${suffix}/pot_es.cube`. The Python script named `tools/average_pot/aveElecStatPot.py` can be used to calculate the average electrostatic potential along the z-axis and outputs it into ElecStaticPot_AVE.\n    Please note that the total local potential refers to the local component of the self-consistent potential, excluding the non-local pseudopotential. The distinction between the local potential and the electrostatic potential is as follows: local potential = electrostatic potential + XC potential.\n  - 3: Apart from 1, also output the **total local potential** of the initial charge density. The files are named as:\n    - nspin = 1: `pots1_ini.cube`;\n    - nspin = 2: `pots1_ini.cube` and `pots2_ini.cube`;\n    - nspin = 4: `pots1_ini.cube`, `pots2_ini.cube`, `pots3_ini.cube`, and `pots4_ini.cube`\n\n  In molecular dynamics calculations, the output frequency is controlled by [out_freq_ion](#out_freq_ion).",
    "enum": [
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_proj_band": {
    "availability": "",
    "default": "False",
    "description": "Whether to output the projected band structure. For more information, refer to the [band.md](../elec_properties/band.md)",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_ri_cv": {
    "availability": "",
    "default": "false",
    "description": "Whether to output the coefficient tensor C(R) and ABFs-representation Coulomb matrix V(R) for each atom pair and cell in real space.",
    "mdType": "Boolean",
    "section": "Exact Exchange (LCAO)",
    "type": "boolean",
    "unit": ""
  },
  "out_spillage": {
    "availability": "Only for Kohn-Sham DFT with plane-wave basis.",
    "default": "0",
    "description": "This output is only intentively needed by the ABACUS numerical atomic orbital generation workflow. This parameter is used to control whether to output the overlap integrals between truncated spherical Bessel functions (TSBFs) and plane-wave basis expanded wavefunctions (named as `OVERLAP_Q`), and between TSBFs (named as `OVERLAP_Sq`), also their first order derivatives. The output files are named starting with `orb_matrix`. A value of `2` would enable the output.",
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_stru": {
    "availability": "",
    "default": "False",
    "description": "Whether to output structure files per ionic step in geometry relaxation calculations into `OUT.${suffix}/STRU_ION${istep}_D`, where `${istep}` is the ionic step.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "out_vecpot": {
    "availability": "",
    "default": "False",
    "description": "Output vector potential or not (unit: a.u.).\n  - True: Output vector potential into file `At.dat`.\n  - False: Do not output vector potential.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "out_wannier_amn": {
    "availability": "",
    "default": "1",
    "description": "Write the \"*.amn\" file or not.\n  - 0: don't write the \"*.amn\" file.\n  - 1: write the \"*.amn\" file.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Bool",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "out_wannier_eig": {
    "availability": "",
    "default": "1",
    "description": "Write the \"*.eig\" file or not.\n  - 0: don't write the \"*.eig\" file.\n  - 1: write the \"*.eig\" file.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Bool",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "out_wannier_mmn": {
    "availability": "",
    "default": "1",
    "description": "Write the \"*.mmn\" file or not.\n  - 0: don't write the \"*.mmn\" file.\n  - 1: write the \"*.mmn\" file.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Bool",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "out_wannier_unk": {
    "availability": "",
    "default": "0",
    "description": "Write the \"UNK.*\" file or not.\n  - 0: don't write the \"UNK.*\" file.\n  - 1: write the \"UNK.*\" file.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Bool",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "out_wannier_wvfn_formatted": {
    "availability": "",
    "default": "1",
    "description": "Write the \"UNK.*\" file in ASCII format or binary format.\n  - 0: write the \"UNK.*\" file in binary format.\n  - 1: write the \"UNK.*\" file in ASCII format (text file format).",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Bool",
    "section": "Berry phase and wannier90 interface",
    "type": "boolean",
    "unit": ""
  },
  "out_wfc_lcao": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder `OUT.${suffix}`. The files are named as `wf{s}{spin index}{k(optional)}{k-point index}{g(optional)}{geometry index1}{_nao} + {\".txt\"/\".dat\"}`. Here, 's' refers to spin, where s1 means spin up channel while s2 means spin down channel, and 's12' refer to spinor wave functions that contains both spin channels with spin-orbital coupling or noncollinear calculations enabled. In addition, if 'gamma_only' is set to 0, then the optinoal k-point sampling index appears with the k-point index attached to the electronic wave function file names. Finally, if [out_app_flag](#out_app_flag) is set to false, the file name contains the optional 'g' index for each ionic step that may have different geometries, and if [out_app_flag](#out_app_flag) is set to true, the wave functions accumulate during ionic steps. If the out_app_flag is set to false, a new folder named WFC will be created, and the wave function files will be saved into it.\n  - 0: no output\n  - 1: (txt format)\n    - gamma-only: `wfs1_nao.txt` or `wfs2_nao.txt`, ...;\n    - non-gamma-only: `wfs1k1_nao.txt` or `wfs1k2_nao.txt`, ...;\n  - 2: (binary format)\n    - gamma-only: `wfs1_nao.dat` or `wfs2_nao.dat`, ...;\n    - non-gamma-only: `wfs1k1_nao.dat` or `wfs1k2_nao.dat`, ....\n\n  The corresponding sequence of the orbitals can be seen in [Basis Set](../pp_orb.md#basis-set).\n\n  Also controled by [out_freq_ion](#out_freq_ion) and [out_app_flag](#out_app_flag).",
    "enum": [
      "0",
      "1",
      "gamma-only",
      "non-gamma-only",
      "2"
    ],
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_wfc_lr (Under Development Feature)": {
    "availability": "",
    "default": "False",
    "description": "Whether to output the eigenstates (excitation energy) and eigenvectors (excitation amplitude) of the LR-TDDFT calculation.\nThe output files are `OUT.${suffix}/Excitation_Energy.dat` and `OUT.${suffix}/Excitation_Amplitude_${processor_rank}.dat`.",
    "mdType": "Boolean",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "boolean",
    "unit": ""
  },
  "out_wfc_norm": {
    "availability": "For both PW and LCAO. When `basis_type = lcao`, used when `calculation = get_wf`.",
    "default": "none",
    "dependencies": {
      "basis_type": "lcao"
    },
    "description": "Specifies the electronic states to calculate the real-space wave function modulus (norm, or known as the envelope function) $|\\psi_i(\\boldsymbol{r})|$ with state index $i$. The syntax and state selection rules are identical to [`out_pchg`](#out_pchg), but the output is the norm of the wave function. The outputs comprise multiple `.cube` files following the naming convention `wfi[state]s[spin]k[kpoint].cube`.",
    "mdType": "String",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_wfc_pw": {
    "availability": "Output electronic wave functions in plane wave basis, or transform the real-space electronic wave function into plane wave basis (see get_wf option in [calculation](#calculation) with NAO basis)",
    "default": "0",
    "description": "Whether to output the electronic wavefunction coefficients into files and store them in the folder `OUT.${suffix}`. The files are named as `wf{k}{k-point index}{s}{spin index}{g}{geometry index}{e}{electronic iteration index}{_pw} + {\".txt\"/\".dat\"}`. Here, the s index refers to spin but the label will not show up for non-spin-polarized calculations, where s1 means spin up channel while s2 means spin down channel, and s4 refers to spinor wave functions that contains both spin channels with spin-orbital coupling or noncollinear calculations enabled. For scf or nscf calculations, g index will not appear, but the g index appears for geometry relaxation and molecular dynamics, where one can use the [out_freq_ion](#out_freq_ion) command to control. To print out the electroinc wave functions every few SCF iterations, use the [out_freq_elec](#out_freq_elec) command and the e index will appear in the file name.\n  - 0: no output\n  - 1: (txt format)\n    - non-gamma-only with nspin=1: `wfk1_pw.txt`, `wfk2_pw.txt`, ...;\n    - non-gamma-only with nspin=2: `wfk1s1_pw.txt`, `wfk1s2_pw.txt`, `wfk2s1_pw.txt`, `wfk2s2_pw.txt`, ...;\n    - non-gamma-only with nspin=4: `wfk1s4_pw.txt`, `wfk2s4_pw.txt`, ...;\n  - 2: (binary format)\n    - non-gamma-only with nspin=1: `wfk1_pw.dat`, `wfk2_pw.dat`, ...;\n    - non-gamma-only with nspin=2: `wfk1s1_pw.dat`, `wfk1s2_pw.dat`, `wfk2s1_pw.dat`, `wfk2s2_pw.dat`, ...;\n    - non-gamma-only with nspin=4: `wfk1s4_pw.dat`, `wfk2s4_pw.dat`, ...;",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Output information",
    "type": "integer",
    "unit": ""
  },
  "out_wfc_re_im": {
    "availability": "For both PW and LCAO. When `basis_type = lcao`, used when `calculation = get_wf`.",
    "default": "none",
    "dependencies": {
      "basis_type": "lcao"
    },
    "description": "Specifies the electronic states to calculate the real and imaginary parts of the wave function $\\text{Re}(\\psi_i(\\boldsymbol{r}))$ and $\\text{Im}(\\psi_i(\\boldsymbol{r}))$ with state index $i$. The syntax and state selection rules are identical to [`out_pchg`](#out_pchg), but the output contains both the real and imaginary components of the wave function. The outputs comprise multiple `.cube` files following the naming convention `wfi[state]s[spin]k[kpoint][re/im].cube`.",
    "mdType": "String",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "out_xc_r": {
    "availability": "",
    "default": "-1 3",
    "description": "The first integer controls whether to output the exchange-correlation (in Bohr^-3) on real space grids using Libxc to folder `OUT.${suffix}`:\n  - 0: rho, amag, sigma, exc\n  - 1: vrho, vsigma\n  - 2: v2rho2, v2rhosigma, v2sigma2\n  - 3: v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3\n  - 4: v4rho4, v4rho3sigma, v4rho2sigma2, v4rhosigma3, v4sigma4\n  The meaning of the files is presented in [Libxc](https://libxc.gitlab.io/manual/libxc-5.1.x/)\n\n  The second integer controls the precision of the charge density output, if not given, will use `3` as default.\n\n  ---\n  The circle order of the charge density on real space grids is: x is the outer loop, then y and finally z (z is moving fastest).",
    "enum": [
      "0",
      "1",
      "2",
      "3",
      "4"
    ],
    "mdType": "Integer \\[Integer\\](optional)",
    "section": "Output information",
    "type": "string",
    "unit": ""
  },
  "pexsi_comm": {
    "availability": "",
    "default": "True",
    "description": "Whether to construct PSelInv communication pattern.",
    "mdType": "Boolean",
    "section": "PEXSI",
    "type": "boolean",
    "unit": ""
  },
  "pexsi_delta_e": {
    "availability": "",
    "default": "20",
    "description": "Upper bound for the spectral radius of $S^{-1} H$.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_elec_thr": {
    "availability": "",
    "default": "0.001",
    "description": "Stopping criterion of the PEXSI iteration in terms of the number of electrons compared to numElectronExact.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_gap": {
    "availability": "",
    "default": "0",
    "description": "Spectral gap, this can be set to be 0 in most cases.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_inertia": {
    "availability": "",
    "default": "True",
    "description": "Whether inertia counting is used at the very beginning.",
    "mdType": "Boolean",
    "section": "PEXSI",
    "type": "boolean",
    "unit": ""
  },
  "pexsi_method": {
    "availability": "",
    "default": "1",
    "description": "The pole expansion method to be used. 1 for Cauchy Contour Integral method, 2 for Moussa optimized method.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_mu": {
    "availability": "",
    "default": "0",
    "description": "Initial guess for mu (for the solver).",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_mu_expand": {
    "availability": "",
    "default": "0.3",
    "description": "If the chemical potential is not in the initial interval, the interval is expanded by this value.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_mu_guard": {
    "availability": "",
    "default": "0.2",
    "description": "Safe guard criterion in terms of the chemical potential to reinvoke the inertia counting procedure.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_mu_lower": {
    "availability": "",
    "default": "-10",
    "description": "Initial guess of lower bound for mu.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_mu_thr": {
    "availability": "",
    "default": "0.05",
    "description": "Stopping criterion in terms of the chemical potential for the inertia counting procedure.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_mu_upper": {
    "availability": "",
    "default": "10",
    "description": "Initial guess of upper bound for mu.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_nmax": {
    "availability": "",
    "default": "80",
    "description": "Maximum number of PEXSI iterations after each inertia counting procedure.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_npole": {
    "availability": "",
    "default": "40",
    "description": "The number of poles used in the pole expansion method, should be a even number.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_nproc": {
    "availability": "",
    "default": "1",
    "dependencies": {
      "pexsi_ordering": false
    },
    "description": "Number of processors for PARMETIS. Only used if pexsi_ordering == 0.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_nproc_pole": {
    "availability": "",
    "default": "1",
    "description": "The point parallelizaion of PEXSI. Recommend two points parallelization.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_ordering": {
    "availability": "",
    "default": "0",
    "description": "Ordering strategy for factorization and selected inversion. 0: Parallel ordering using ParMETIS, 1: Sequential ordering using METIS, 2: Multiple minimum degree ordering",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_row_ordering": {
    "availability": "",
    "default": "1",
    "description": "Row permutation strategy for factorization and selected inversion, 0: No row permutation, 1: Make the diagonal entry of the matrix larger than the off-diagonal entries.",
    "mdType": "Integer",
    "section": "PEXSI",
    "type": "integer",
    "unit": ""
  },
  "pexsi_storage": {
    "availability": "",
    "default": "True",
    "description": "Whether to use symmetric storage space used by the Selected Inversion algorithm for symmetric matrices.",
    "mdType": "Boolean",
    "section": "PEXSI",
    "type": "boolean",
    "unit": ""
  },
  "pexsi_symm": {
    "availability": "",
    "default": "True",
    "description": "Whether the matrix is symmetric.",
    "mdType": "Boolean",
    "section": "PEXSI",
    "type": "boolean",
    "unit": ""
  },
  "pexsi_temp": {
    "availability": "",
    "default": "0.015",
    "description": "Temperature in Fermi-Dirac distribution, in Ry, should have the same effect as the smearing sigma when smearing method is set to Fermi-Dirac.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pexsi_trans": {
    "availability": "",
    "default": "False",
    "description": "Whether to factorize the transpose of the matrix.",
    "mdType": "Boolean",
    "section": "PEXSI",
    "type": "boolean",
    "unit": ""
  },
  "pexsi_zero_thr": {
    "availability": "",
    "default": "1e-10",
    "description": "if the absolute value of CCS matrix element is less than this value, it will be considered as zero.",
    "mdType": "Real",
    "section": "PEXSI",
    "type": "number",
    "unit": ""
  },
  "pot_file": {
    "availability": "",
    "default": "graph.pb",
    "description": "The filename of DP/NEP potential files, see [md.md](../md.md#dpmd) in detail.",
    "mdType": "String",
    "section": "Molecular dynamics",
    "type": "string",
    "unit": ""
  },
  "precision": {
    "availability": "Used only for plane wave basis set.",
    "default": "double",
    "description": "Specifies the precision when performing scf calculation.\n  - single: single precision\n  - double: double precision",
    "enum": [
      "single",
      "double"
    ],
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "press1": {
    "availability": "",
    "default": "0",
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress.",
    "exclusiveMinimum": 0,
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "kbar"
  },
  "press2": {
    "availability": "",
    "default": "0",
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress.",
    "exclusiveMinimum": 0,
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "kbar"
  },
  "press3": {
    "availability": "",
    "default": "0",
    "description": "The external pressures along three axes. Positive input value is taken as compressive stress.",
    "exclusiveMinimum": 0,
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "kbar"
  },
  "pseudo_dir": {
    "availability": "",
    "default": "\"\"",
    "description": "The direcotyr of pseudopotential files.\n  - This parameter is combined with the pseudopotential filenames in the STRU file to form the complete pseudopotential file paths.\n  - Example: set pseudo_dir to \"../\" with \"Si.upf\" which specified under \"ATOMIC_SPECIES\" in STRU file, ABACUS will open the pseudopotential file in path \"../Si.upf\".",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "pseudo_mesh": {
    "availability": "",
    "default": "0",
    "description": "- 0: Use a mesh for radial integration of pseudopotentials.\n  - 1: Use the mesh that is consistent with quantum espresso",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "pseudo_rcut": {
    "availability": "",
    "default": "15",
    "description": "Cut-off of radial integration for pseudopotentials.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "Bohr"
  },
  "pw_diag_ndim": {
    "availability": "",
    "default": "4",
    "description": "Only useful when you use `ks_solver = dav` or `ks_solver = dav_subspace`. It indicates dimension of workspace(number of wavefunction packets, at least 2 needed) for the Davidson method. A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization.",
    "mdType": "Integer",
    "minimum": 2.0,
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "pw_diag_nmax": {
    "availability": "",
    "default": "40",
    "description": "Only useful when you use `ks_solver = cg/dav/dav_subspace/bpcg`. It indicates the maximal iteration number for cg/david/dav_subspace/bpcg method.",
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "pw_diag_thr": {
    "availability": "",
    "default": "0.01",
    "description": "Only used when you use `ks_solver = cg/dav/dav_subspace/bpcg`. It indicates the threshold for the first electronic iteration, from the second iteration the pw_diag_thr will be updated automatically. **For nscf calculations with planewave basis set, pw_diag_thr should be <= 1e-3.**",
    "mdType": "Real",
    "section": "Plane wave related variables",
    "type": "number",
    "unit": ""
  },
  "pw_seed": {
    "availability": "Only used for plane wave basis.",
    "default": "0",
    "description": "Specify the random seed to initialize wave functions. Only positive integers are available.",
    "exclusiveMinimum": 0,
    "mdType": "Integer",
    "section": "Plane wave related variables",
    "type": "integer",
    "unit": ""
  },
  "qo_basis (Under Development Feature)": {
    "availability": "",
    "default": "`szv`",
    "description": "Specify the type of atomic basis\n  - `pswfc`: use the pseudowavefunction in pseudopotential files as atomic basis. To use this option, please make sure in pseudopotential file there is pswfc in it.\n  - `hydrogen`: generate hydrogen-like atomic basis (or with Slater screening).\n  - `szv`: use the first set of zeta for each angular momentum from numerical atomic orbitals as atomic basis.\n\n  *warning: to use* `pswfc` *, please use norm-conserving pseudopotentials with pseudowavefunctions, SG15 pseudopotentials cannot support this option.*\n  *Developer notes: for ABACUS-lcao calculation, it is the most recommend to use `szv` instead of `pswfc` which is originally put forward in work of QO implementation on PW basis. The information loss always happens if `pswfc` or `hydrogen` orbitals are not well tuned, although making kpoints sampling more dense will mitigate this problem, but orbital-adjust parameters are needed to test system-by-system in this case.*",
    "enum": [
      "pswfc",
      "hydrogen",
      "szv",
      "warning"
    ],
    "mdType": "String",
    "section": "Quasiatomic Orbital (QO) analysis (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "qo_screening_coeff (Under Development Feature)": {
    "availability": "",
    "default": "0.1",
    "description": "rescale the shape of radial orbitals, available for both `qo_basis hydrogen` and `qo_basis pswfc`. cases but has different meaning.\n\n  For `qo_basis pswfc`\n  For each atom type, screening factor $e^{-\\eta|\\mathbf{r}|}$ is multiplied to the pswfc to mimic the behavior of some kind of electron. $\\eta$ is the screening coefficient. If only one value is given, then will apply to each atom type. If not enough values are given, will apply default value to rest of atom types. This parameter plays important role in controlling the spread of QO orbitals together with `qo_thr`.\n\n  For `qo_basis hydrogen`\n  If any float number is given, will apply Slater screening to all atom types. Slater screening is a classic and empirical method roughly taking many-electron effect into account for obtaining more accurate results when evaluating electron affinity and ionization energy. The Coulomb potential then becomes $V(r) = -\\frac{Z-\\sigma}{r}$. For example the effective nuclear charge for Cu 3d electrons now reduces from 29 to 7.85, 4s from 29 to 3.70, which means Slater screening will bring about longer tailing effect. If no value is given, will not apply Slater screening.",
    "mdType": "Real \\[Real...\\](optional)",
    "section": "Quasiatomic Orbital (QO) analysis (Under Development Feature)",
    "type": "string",
    "unit": "Bohr^-1"
  },
  "qo_strategy (Under Development Feature)": {
    "availability": "",
    "default": "for `hydrogen`: `energy-valence`, for `pswfc` and `szv`: `all`",
    "description": "Specify the strategy to generate radial orbitals for each atom type. If one parameter is given, will apply to all atom types. If more than one parameters are given but fewer than number of atom type, those unspecified atom type will use default value.\n\n  For `qo_basis hydrogen`\n  - `minimal-nodeless`: according to principle quantum number of the highest occupied state, generate only nodeless orbitals, for example Cu, only generate 1s, 2p, 3d and 4f orbitals (for Cu, 4s is occupied, thus $n_{max} = 4$)\n  - `minimal-valence`: according to principle quantum number of the highest occupied state, generate only orbitals with highest principle quantum number, for example Cu, only generate 4s, 4p, 4d and 4f orbitals.\n  - `full`: similarly according to the maximal principle quantum number, generate all possible orbitals, therefore for Cu, for example, will generate 1s, 2s, 2p, 3s, 3p, 3d, 4s, 4p, 4d, 4f.\n  - `energy-full`: will generate hydrogen-like orbitals according to Aufbau principle. For example the Cu (1s2 2s2 2p6 3s2 3p6 3d10 4s1), will generate these orbitals.\n  - `energy-valence`: from the highest n (principal quantum number) layer and n-1 layer, generate all occupied and possible ls (angular momentum quantum number) for only once, for example Cu, will generate 4s, 3d and 3p orbitals.\n\n  For `qo_basis pswfc` and `qo_basis szv`\n  - `all`: use all possible pseudowavefunctions/numerical atomic orbital (of first zeta) in pseudopotential/numerical atomic orbital file.\n  - `s`/`p`/`d`/...: only use s/p/d/f/...-orbital(s).\n  - `spd`: use s, p and d orbital(s). Any unordered combination is acceptable.\n\n  *warning: for* `qo_basis hydrogen` *to use* `full`, *generation strategy may cause the space spanned larger than the one spanned by numerical atomic orbitals, in this case, must filter out orbitals in some way*",
    "enum": [
      "minimal-nodeless",
      "minimal-valence",
      "full",
      "energy-full",
      "energy-valence",
      "all",
      "spd",
      "warning"
    ],
    "mdType": "String \\[String...\\](optional)",
    "section": "Quasiatomic Orbital (QO) analysis (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "qo_switch (Under Development Feature)": {
    "availability": "",
    "default": "0",
    "description": "Whether to let ABACUS output QO analysis required files",
    "mdType": "Boolean",
    "section": "Quasiatomic Orbital (QO) analysis (Under Development Feature)",
    "type": "boolean",
    "unit": ""
  },
  "qo_thr (Under Development Feature)": {
    "availability": "",
    "default": "1.0e-6",
    "description": "The convergence threshold determining the cutoff of generated orbital. Lower threshold will yield orbital with larger cutoff radius.",
    "mdType": "Real",
    "section": "Quasiatomic Orbital (QO) analysis (Under Development Feature)",
    "type": "number",
    "unit": ""
  },
  "rdmft (Under Development Feature)": {
    "availability": "",
    "default": "false",
    "description": "Whether to perform rdmft calculation (reduced density matrix funcional theory)",
    "mdType": "Boolean",
    "section": "Reduced Density Matrix Functional Theory (Under Development Feature)",
    "type": "boolean",
    "unit": ""
  },
  "rdmft_power_alpha (Under Development Feature)": {
    "availability": "",
    "default": "0.656",
    "description": "The alpha parameter of power-functional(or other exx-type/hybrid functionals) which used in RDMFT, g(occ_number) = occ_number^alpha",
    "mdType": "Real",
    "section": "Reduced Density Matrix Functional Theory (Under Development Feature)",
    "type": "number",
    "unit": ""
  },
  "read_file_dir": {
    "availability": "",
    "default": "OUT.$suffix",
    "description": "Location of files, such as the electron density (`chgs1.cube`), required as a starting point.\n  - Example: './' implies the files to be read are located in the working directory.",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "ref_cell_factor": {
    "availability": "",
    "default": "1.0",
    "description": "Construct a reference cell bigger than the initial cell. The reference cell has to be large enough so that the lattice vectors of the fluctuating cell do not exceed the reference lattice vectors during MD. Typically, 1.02 ~ 1.10 is sufficient. However, the cell fluctuations depend on the specific system and thermodynamic conditions. So users must test for a proper choice. This parameters should be used in conjunction with [erf_ecut](#erf_ecut), [erf_height](#erf_height), and [erf_sigma](#erf_sigma).",
    "mdType": "Real",
    "section": "Molecular dynamics",
    "type": "number",
    "unit": ""
  },
  "relax_bfgs_init": {
    "availability": "Only used when `relax_new = False` and `relax_method` is `bfgs` or `cg_bfgs`",
    "default": "0.5",
    "dependencies": {
      "relax_new": false
    },
    "description": "Initial total displacement of all atoms in the first BFGS step. This sets the scale for the initial movement.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "Bohr"
  },
  "relax_bfgs_rmax": {
    "availability": "Only used when `relax_new = False` and `relax_method` is `bfgs` or `cg_bfgs`",
    "default": "0.8",
    "dependencies": {
      "relax_new": false
    },
    "description": "Maximum allowed total displacement of all atoms during geometry optimization. The sum of atomic displacements can increase during optimization steps but cannot exceed this value.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "Bohr"
  },
  "relax_bfgs_rmin": {
    "availability": "Only used when `relax_new = False` and `relax_method = bfgs 1` (traditional BFGS)",
    "default": "1e-5",
    "dependencies": {
      "relax_new": false
    },
    "description": "Minimum allowed total displacement of all atoms. When the total atomic displacement falls below this value and force convergence is not achieved, the calculation will terminate. **Note**: This parameter is not used in the default BFGS algorithm (`relax_method = bfgs 2` or `bfgs`).",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "Bohr"
  },
  "relax_bfgs_w1": {
    "availability": "Only used when `relax_new = False` and `relax_method` is `bfgs` or `cg_bfgs`",
    "default": "0.01",
    "dependencies": {
      "relax_new": false
    },
    "description": "Controls the Wolfe condition for the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. This parameter sets the sufficient decrease condition (c1 in Wolfe conditions). For more information, see Phys. Chem. Chem. Phys., 2000, 2, 2177.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": ""
  },
  "relax_bfgs_w2": {
    "availability": "Only used when `relax_new = False` and `relax_method` is `bfgs` or `cg_bfgs`",
    "default": "0.5",
    "dependencies": {
      "relax_new": false
    },
    "description": "Controls the Wolfe condition for the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. This parameter sets the curvature condition (c2 in Wolfe conditions). For more information, see Phys. Chem. Chem. Phys., 2000, 2, 2177.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": ""
  },
  "relax_cg_thr": {
    "availability": "Only used when `relax_new = False` and `relax_method = cg_bfgs`",
    "default": "0.5",
    "dependencies": {
      "relax_new": false
    },
    "description": "When `relax_method` is set to `cg_bfgs`, a mixed algorithm of conjugate gradient (CG) and Broyden–Fletcher–Goldfarb–Shanno (BFGS) is used. The ions first move according to the CG method, then switch to the BFGS method when the maximum force on atoms is reduced below this threshold.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "eV/Angstrom"
  },
  "relax_method": {
    "availability": "",
    "default": "`cg 1`",
    "dependencies": {
      "relax_new": false
    },
    "description": "The methods to do geometry optimization. The available algorithms depend on the [relax_new](#relax_new) setting.\n\n  **First element** (algorithm selection):\n  - `cg`: Conjugate gradient (CG) algorithm. Available for both `relax_new = True` (default, simultaneous optimization) and `relax_new = False` (nested optimization). See [relax_new](#relax_new) for implementation details.\n  - `bfgs`: Broyden–Fletcher–Goldfarb–Shanno (BFGS) quasi-Newton algorithm. **Only available when `relax_new = False`**.\n  - `lbfgs`: Limited-memory BFGS algorithm, suitable for large systems. **Only available when `relax_new = False`**.\n  - `cg_bfgs`: Mixed method starting with CG and switching to BFGS when force convergence reaches [relax_cg_thr](#relax_cg_thr). **Only available when `relax_new = False`**.\n  - `sd`: Steepest descent algorithm. **Only available when `relax_new = False`**. Not recommended for production use.\n  - `fire`: Fast Inertial Relaxation Engine method, a molecular-dynamics-based relaxation algorithm. Use by setting [calculation](#calculation) to `md` and [md_type](#md_type) to `fire`. Ionic velocities must be set in STRU file. See [fire](../md.md#fire) for details.\n\n  **Second element** (BFGS variant, only when first element is `bfgs`):\n  - `1`: Traditional BFGS that updates the Hessian matrix B and then inverts it.\n  - `2` or omitted: Default BFGS that directly updates the inverse Hessian (recommended).",
    "enum": [
      "cg",
      "bfgs",
      "lbfgs",
      "cg_bfgs",
      "sd",
      "fire",
      "1"
    ],
    "mdType": "Vector of string",
    "section": "Geometry relaxation",
    "type": "string",
    "unit": ""
  },
  "relax_new": {
    "availability": "",
    "default": "True",
    "description": "Controls which implementation of geometry relaxation to use. At the end of 2022, a new implementation of the Conjugate Gradient (CG) method was introduced for `relax` and `cell-relax` calculations, while the old implementation was kept for backward compatibility.\n\n  - **True** (default): Use the new CG implementation with the following features:\n    - Simultaneous optimization of ionic positions and cell parameters (for `cell-relax`)\n    - Line search algorithm for step size determination\n    - Only CG algorithm is available (`relax_method` must be `cg`)\n    - Supports advanced cell constraints: `fixed_axes = \"shape\"`, `\"volume\"`, `\"a\"`, `\"b\"`, `\"c\"`, etc.\n    - Supports `fixed_ibrav` to maintain lattice type\n    - More efficient for variable-cell relaxation\n    - Step size controlled by [relax_scale_force](#relax_scale_force)",
    "mdType": "Boolean",
    "section": "Geometry relaxation",
    "type": "boolean",
    "unit": ""
  },
  "relax_nmax": {
    "availability": "",
    "default": "1 for SCF, 50 for relax and cell-relax calcualtions",
    "description": "The maximal number of ionic iteration steps. If set to 0, the code performs a quick \"dry run\", stopping just after initialization. This is useful to check for input correctness and to have the summary printed.",
    "mdType": "Integer",
    "section": "Geometry relaxation",
    "type": "integer",
    "unit": ""
  },
  "relax_scale_force": {
    "availability": "Only used when `relax_new` set to `True`",
    "default": "0.5",
    "description": "The paramether controls the size of the first conjugate gradient step. A smaller value means the first step along a new CG direction is smaller. This might be helpful for large systems, where it is safer to take a smaller initial step to prevent the collapse of the whole configuration.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": ""
  },
  "restart_load": {
    "availability": "Used only when numerical atomic orbitals are employed as basis set.",
    "default": "False",
    "description": "If [restart_save](#restart_save) is set to true and an electronic iteration is finished, calculations can be restarted from the charge density file, which are saved in the former calculation. Please ensure [read_file_dir](#read_file_dir) is correct, and  the charge density file exist.\n\n  If EXX(exact exchange) is calculated (i.e. *[dft_fuctional](#dft_functional)==hse/hf/pbe0/scan0* or *[rpa](#rpa)==True*), the Hexx(R) files in the same folder for each processor will also be read.",
    "mdType": "Boolean",
    "section": "Input files",
    "type": "boolean",
    "unit": ""
  },
  "restart_save": {
    "availability": "Numerical atomic orbital basis",
    "default": "False",
    "description": "Whether to save charge density files per ionic step, which are used to restart calculations. According to the value of [read_file_dir](#read_file_dir):\n  - auto: These files are saved in folder `OUT.${suffix}/restart/`;\n  - other: These files are saved in folder `${read_file_dir}/restart/`.\n\n  If EXX(exact exchange) is calculated (i.e. *[dft_fuctional](#dft_functional)==hse/hf/pbe0/scan0* or *[rpa](#rpa)==True*), the Hexx(R) files for each processor will also be saved in the above folder, which can be read in EXX calculation with *[restart_load](#restart_load)==True*.",
    "enum": [
      "auto",
      "other"
    ],
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "ri_hartree_benchmark (Under Development Feature)": {
    "availability": "",
    "default": "none",
    "description": "Whether to use the localized resolution-of-identity (LRI) approximation for the **Hartree** term of kernel in the $A$ matrix of LR-TDDFT for benchmark (with FHI-aims or another ABACUS calculation). Now it only supports molecular systems running with a single processor, and a large enough supercell should be used to make LRI C, V tensors contain only the R=(0 0 0) cell.\n  - `aims`: The `OUT.${suffix}`directory should contain the FHI-aims output files: RI-LVL tensors`Cs_data_0.txt` and `coulomb_mat_0.txt`, and KS eigenstates from FHI-aims: `band_out`and `KS_eigenvectors.out`. The Casida equation will be constructed under FHI-aims' KS eigenpairs.\n    - LRI tensor files (`Cs_data_0.txt` and `coulomb_mat_0.txt`)and Kohn-Sham eigenvalues (`bands_out`): run FHI-aims with periodic boundary conditions and with `total_energy_method rpa` and `output librpa`.\n    - Kohn-Sham eigenstates under aims NAOs (`KS_eigenvectors.out`): run FHI-aims with `output eigenvectors`.\n    - If the number of atomic orbitals of any atom type in FHI-aims is different from that in ABACUS, the `aims_nbasis` should be set.\n  - `abacus`: The `OUT.${suffix}`directory should contain the RI-LVL tensors `Cs` and `Vs` (written by setting `out_ri_cv` to 1). The Casida equation will be constructed under ABACUS' KS eigenpairs, with the only difference that the Hartree term is constructed with RI approximation.\n  - `none`: Construct the Hartree term by Poisson equation and grid integration as usual.",
    "enum": [
      "aims",
      "abacus",
      "none"
    ],
    "mdType": "String",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "rpa (Under Development Feature)": {
    "availability": "",
    "default": "False",
    "description": "Generate output files used in rpa calculations.",
    "mdType": "Boolean",
    "section": "Output information",
    "type": "boolean",
    "unit": ""
  },
  "rpa_ccp_rmesh_times": {
    "availability": "",
    "default": "10",
    "description": "How many times larger the radial mesh required is to that of atomic orbitals in the postprocess calculation of the **bare** Coulomb matrix for RPA, GW, etc.",
    "mdType": "Real",
    "section": "Exact Exchange (LCAO)",
    "type": "number",
    "unit": ""
  },
  "sc_os_ndim": {
    "availability": "",
    "default": "5",
    "description": "To determine the number of old iterations to judge oscillation, it occured,  more accurate lambda with DeltaSpin method would be calculated, only for PW base.",
    "mdType": "int",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "scf_ene_thr": {
    "availability": "",
    "default": "-1.0. If the user does not set this parameter, it will not take effect.",
    "description": "It's the energy threshold for electronic iteration. It represents the total energy error between two sequential densities from electronic iterations.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "eV"
  },
  "scf_nmax": {
    "availability": "",
    "default": "100",
    "description": "This variable indicates the maximal iteration number for electronic iterations.",
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "scf_os_ndim": {
    "availability": "",
    "default": "`mixing_ndim`",
    "description": "To determine the number of old iterations' `drho` used in slope calculations.",
    "mdType": "int",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "scf_os_stop": {
    "availability": "",
    "default": "false",
    "description": "For systems that are difficult to converge, the SCF process may exhibit oscillations in charge density, preventing further progress toward the specified convergence criteria and resulting in continuous oscillation until the maximum number of steps is reached; this greatly wastes computational resources. To address this issue, this function allows ABACUS to terminate the SCF process early upon detecting oscillations, thus reducing subsequent meaningless calculations. The detection of oscillations is based on the slope of the logarithm of historical drho values.. To this end, Least Squares Method is used to calculate the slope of the logarithmically taken drho for the previous `scf_os_ndim` iterations. If the calculated slope is larger than `scf_os_thr`, stop the SCF.\n\n  - 0: The SCF will continue to run regardless of whether there is oscillation or not.\n  - 1: If the calculated slope is larger than `scf_os_thr`, stop the SCF.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "bool",
    "section": "Electronic structure",
    "type": "boolean",
    "unit": ""
  },
  "scf_os_thr": {
    "availability": "",
    "default": "-0.01",
    "description": "The slope threshold to determine if the SCF is stuck in a charge density oscillation. If the calculated slope is larger than `scf_os_thr`, stop the SCF.",
    "mdType": "double",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "scf_thr": {
    "availability": "",
    "default": "1.0e-9 (plane-wave basis), or 1.0e-7 (localized atomic orbital basis).",
    "description": "It's the density threshold for electronic iteration. It represents the charge density error between two sequential densities from electronic iterations. Usually for local orbitals, usually 1e-6 may be accurate enough.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "Ry if `scf_thr_type=1`, **dimensionless** if `scf_thr_type=2`"
  },
  "scf_thr_type": {
    "availability": "",
    "default": "1 (plane-wave basis), or 2 (localized atomic orbital basis).",
    "description": "Choose the calculation method of convergence criterion.\n  - 1: the criterion is defined as $\\Delta\\rho_G = \\frac{1}{2}\\iint{\\frac{\\Delta\\rho(r)\\Delta\\rho(r')}{|r-r'|}d^3r d^3r'}$, which is used in SCF of PW basis with unit Ry.\n  - 2: the criterion is defined as $\\Delta\\rho_R = \\frac{1}{N_e}\\int{|\\Delta\\rho(r)|d^3r}$, where $N_e$ is the number of electron, which is used in SCF of LCAO with unit **dimensionless**.",
    "enum": [
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Electronic structure",
    "type": "integer",
    "unit": ""
  },
  "search_radius": {
    "availability": "",
    "default": "-1",
    "description": "Searching radius in finding the neighbouring atoms. By default the radius will be automatically determined by the cutoffs of orbitals and nonlocal beta projectors.",
    "mdType": "Real",
    "section": "Numerical atomic orbitals related variables",
    "type": "number",
    "unit": "Bohr"
  },
  "seed_sto": {
    "availability": "[esolver_type](#esolver_type) = `sdft`",
    "default": "0",
    "description": "The random seed to generate stochastic orbitals.\n  - \\>= 0: Stochastic orbitals have the form of $\\exp(i2\\pi\\theta(G))$, where $\\theta$ is a uniform distribution in $(0,1)$.\n  - 0: the seed is decided by time(NULL).\n  - \\<= -1: Stochastic orbitals have the form of $\\pm1$ with equal probability.\n  - -1: the seed is decided by time(NULL).",
    "enum": [
      "0",
      "-1"
    ],
    "mdType": "Integer",
    "section": "Electronic structure (SDFT)",
    "type": "integer",
    "unit": ""
  },
  "sigma_k": {
    "availability": "",
    "default": "0.6",
    "description": "The width of the diffuse cavity that is implicitly determined by the electronic structure of the solute",
    "mdType": "Real",
    "section": "Implicit solvation model",
    "type": "number",
    "unit": ""
  },
  "smearing_method": {
    "availability": "",
    "default": "gauss",
    "description": "It indicates which occupation and smearing method is used in the calculation.\n  - fixed: fixed occupations (available for non-coductors only)\n  - gauss or gaussian: Gaussian smearing method.\n  - mp: methfessel-paxton smearing method; recommended for metals.\n  - mp2: 2-nd methfessel-paxton smearing method; recommended for metals.\n  - mv or cold: marzari-vanderbilt smearing method.\n  - fd: Fermi-Dirac smearing method: $f=1/\\{1+\\exp[(E-\\mu)/kT]\\}$ and smearing_sigma below is the temperature $T$ (in Ry).",
    "enum": [
      "fixed",
      "gauss",
      "gaussian",
      "mp",
      "mp2",
      "mv",
      "cold",
      "fd"
    ],
    "mdType": "String",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "smearing_sigma": {
    "availability": "",
    "default": "0.015",
    "description": "Energy range for smearing.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "Ry"
  },
  "smearing_sigma_temp": {
    "availability": "",
    "default": "2 * `smearing_sigma` / kB.",
    "description": "Energy range for smearing, `smearing_sigma` = 1/2 *kB* `smearing_sigma_temp`.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "K"
  },
  "soc_lambda": {
    "availability": "Only works when `lspinorb=true`",
    "default": "1.0",
    "description": "Modulates the strength of spin-orbit coupling effect. Sometimes, for some real materials, both scalar-relativistic and full-relativistic pseudopotentials cannot describe the exact spin-orbit coupling. Artificial modulation may help in such cases.\n\n  `soc_lambda`, which has value range [0.0, 1.0], is used to modulate SOC effect:\n  - `soc_lambda 0.0`: Scalar-relativistic case (no SOC)\n  - `soc_lambda 1.0`: Full-relativistic case (full SOC)\n  - Intermediate values: Partial-relativistic SOC (interpolation between scalar and full)\n\n  **Use case**: When experimental or high-level theoretical results suggest that the SOC effect is weaker or stronger than what full-relativistic pseudopotentials predict, you can adjust this parameter to match the target behavior.",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": ""
  },
  "spillage_outdir": {
    "availability": "Used only for plane wave basis set.",
    "default": "\"./\"",
    "description": "The directory to save the spillage files.",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "stm_bias": {
    "availability": "",
    "default": "1.0",
    "description": "The bias voltage used to calculate local density of states to simulate scanning tunneling microscope, see details in [out_ldos](#out_ldos). When using three parameters:\n\n  - The first parameter specifies the initial bias voltage value.\n  - The second parameter defines the voltage increment (step size between consecutive bias values).\n  - The third parameter determines the total number of voltage points",
    "mdType": "Real Real(optional) Integer(optional)",
    "section": "Density of states",
    "type": "string",
    "unit": "V"
  },
  "stress_thr": {
    "availability": "",
    "default": "0.5",
    "description": "The threshold of the stress convergence. The threshold is compared with the largest component of the stress tensor.",
    "mdType": "Real",
    "section": "Geometry relaxation",
    "type": "number",
    "unit": "kbar"
  },
  "stru_file": {
    "availability": "",
    "default": "STRU",
    "description": "The name of the structure file.\n  - Containing various information about atom species, including pseudopotential files, local orbitals files, cell information, atom positions, and whether atoms should be allowed to move.\n  - When [calculation](#calculation) is set to `md` and [md_restart](#md_restart) is set to `true`, this keyword will NOT work.\n  - Refer to [Doc](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/stru.md)",
    "mdType": "String",
    "section": "Input files",
    "type": "string",
    "unit": ""
  },
  "suffix": {
    "availability": "",
    "default": "ABACUS",
    "description": "In each run, ABACUS will generate a subdirectory in the working directory. This subdirectory contains all the information of the run. The subdirectory name has the format: OUT.suffix, where the `suffix` is the name you can pick up for your convenience.",
    "mdType": "String",
    "section": "System variables",
    "type": "string",
    "unit": ""
  },
  "symmetry": {
    "availability": "",
    "default": "- 0:\n    - if [calculation](#calculation)==md/nscf/get_pchg/get_wf/get_s or [gamma_only](#gamma_only)==True;\n    - If ([dft_fuctional](#dft_functional)==hse/hf/pbe0/scan0 or [rpa](#rpa)==True).\n    - If [efield_flag](#efield_flag)==1\n  - 1: else",
    "description": "takes value 1, 0 or -1.\n  - -1: No symmetry will be considered. It is recommended to set -1 for non-colinear + soc calculations, where time reversal symmetry is broken sometimes.\n  - 0: Only time reversal symmetry would be considered in symmetry operations, which implied k point and -k point would be treated as a single k point with twice the weight.\n  - 1: Symmetry analysis will be performed to determine the type of Bravais lattice and associated symmetry operations. (point groups, space groups, primitive cells, and irreducible k-points)",
    "enum": [
      "-1",
      "0",
      "1"
    ],
    "mdType": "Integer",
    "section": "System variables",
    "type": "integer",
    "unit": ""
  },
  "symmetry_autoclose": {
    "availability": "*[symmetry](#symmetry)==1*",
    "default": "True",
    "description": "Control how to deal with error in symmetry analysis due to inaccurate lattice parameters or atom positions in STRU file, especially useful when *[calculation](#calculation)==cell-relax*\n  - False: quit with an error message\n  - True: automatically set symmetry to 0 and continue running without symmetry analysis",
    "mdType": "Boolean",
    "section": "System variables",
    "type": "boolean",
    "unit": ""
  },
  "symmetry_prec": {
    "availability": "",
    "default": "1.0e-6",
    "description": "The accuracy for symmetry analysis. Typically, the default value is good enough, but if the lattice parameters or atom positions in STRU file are not accurate enough, this value should be enlarged.\n  > Note: if *[calculation](#calculation)==cell_relax*, this value can be dynamically changed corresponding to the variation of accuracy of the lattice parameters and atom positions during the relaxation. The new value will be printed in `OUT.${suffix}/running_cell-relax.log` in that case.",
    "mdType": "Real",
    "section": "System variables",
    "type": "number",
    "unit": "Bohr"
  },
  "t_in_h": {
    "availability": "",
    "default": "1",
    "description": "Specify whether to include kinetic term in obtaining the Hamiltonian matrix.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "tau": {
    "availability": "",
    "default": "1.0798e-05",
    "description": "The effective surface tension parameter that describes the cavitation, the dispersion, and the repulsion interaction between the solute and the solvent which are not captured by the electrostatic terms",
    "mdType": "Real",
    "section": "Implicit solvation model",
    "type": "number",
    "unit": "$Ry/Bohr^{2}$"
  },
  "td_dt": {
    "availability": "",
    "default": "`md_dt / estep_per_md`",
    "description": "The time step used in electronic propagation. Setting `td_dt` will reset the value of [`md_dt`](#md_dt) to `td_dt * estep_per_md`.",
    "mdType": "Real",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "number",
    "unit": "fs"
  },
  "td_edm": {
    "availability": "",
    "default": "0",
    "description": "Method to calculate the energy-density matrix, mainly affects the calculation of force and stress.\n  - 0: Using the original formula: $\\mathrm{EDM}_{\\mu\\nu}=\\frac{1}{2} \\sum_{\\eta \\zeta}\\left(S_{\\mu \\eta}^{-1} H_{\\eta \\zeta} \\rho_{\\zeta \\nu}+\\rho_{\\mu \\eta} H_{\\eta \\zeta} S_{\\zeta \\nu}^{-1}\\right)$.\n  - 1: Using the formula for ground state (deprecated): $\\mathrm{EDM}_{\\mu\\nu}=\\sum_n^{\\mathrm{occ}} c_{\\mu,n} f_n \\epsilon_n c_{n,\\nu}$. Note that this usually does not hold if wave function is not the eigenstate of the Hamiltonian.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "td_gauss_amp": {
    "availability": "",
    "default": "0.25",
    "description": "Amplitude $A$ of the Gaussian type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "V/Å"
  },
  "td_gauss_freq": {
    "availability": "",
    "default": "22.13",
    "description": "Frequency $f$ of the Gaussian type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "1/fs"
  },
  "td_gauss_phase": {
    "availability": "",
    "default": "0.0",
    "description": "Phase $\\varphi$ of the Gaussian type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_gauss_sigma": {
    "availability": "",
    "default": "30.0",
    "description": "Pulse width (standard deviation) $\\sigma$ of the Gaussian type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "fs"
  },
  "td_gauss_t0": {
    "availability": "",
    "default": "100",
    "description": "Step number of the time center $t_0$ of the Gaussian type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_heavi_amp": {
    "availability": "",
    "default": "1.0",
    "description": "Amplitude $A$ of the Heaviside type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "V/Å"
  },
  "td_heavi_t0": {
    "availability": "",
    "default": "100",
    "description": "Step number of the switch time $t_0$ of the Heaviside type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_lcut1": {
    "availability": "",
    "default": "0.05",
    "description": "The lower bound of the interval in the length gauge RT-TDDFT, where $x$ is the fractional coordinate:\n\n  $\n    E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases}\n  $",
    "mdType": "Real",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "number",
    "unit": ""
  },
  "td_lcut2": {
    "availability": "",
    "default": "0.95",
    "description": "The upper bound of the interval in the length gauge RT-TDDFT, where $x$ is the fractional coordinate:\n\n  $\n    E(x)=\\begin{cases}E_0, & \\mathtt{cut1}\\leqslant x \\leqslant \\mathtt{cut2} \\\\-E_0\\left(\\dfrac{1}{\\mathtt{cut1}+1-\\mathtt{cut2}}-1\\right), & 0 < x < \\mathtt{cut1~~or~~cut2} < x < 1 \\end{cases}\n  $",
    "mdType": "Real",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "number",
    "unit": ""
  },
  "td_print_eij": {
    "availability": "",
    "default": "-1",
    "description": "Controls the printing of Hamiltonian matrix elements $E_{ij}=\\Braket{\\psi_i|\\hat{H}|\\psi_j}$.\n  - $<0$: Suppress all $E_{ij}$ output.\n  - $\\geqslant 0$: Print only elements with ​​either $|\\text{Re}(E_{ij})|$ or $|\\text{Im}(E_{ij})|$​​ exceeding `td_print_eij`.",
    "mdType": "Real",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "number",
    "unit": "Ry"
  },
  "td_propagator": {
    "availability": "",
    "default": "0",
    "description": "Methods of electronic propagation: $\\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_2) = U(t_2,t_1) \\psi_{n\\boldsymbol{k}}(\\boldsymbol{r},t_1)$.\n  - 0: Crank-Nicolson, based on matrix inversion: $U = \\dfrac{S_{\\boldsymbol{k}}-\\mathrm{i}  H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}{S_{\\boldsymbol{k}}+\\mathrm{i}  H_{\\boldsymbol{k}}((t_1+t_2)/2) \\Delta t / 2}$.\n  - 1: 4th-order Taylor expansion of exponential: $U = I + \\hat{A} + \\frac{1}{2}\\hat{A}^2 + \\frac{1}{6}\\hat{A}^3 + \\frac{1}{24}\\hat{A}^4$, where $\\hat{A} = -\\mathrm{i} S_{\\boldsymbol{k}}^{-1} H_{\\boldsymbol{k}}((t_1+t_2)/2)\\Delta t$.\n  - 2: Enforced time-reversal symmetry (ETRS): $U = \\mathrm{e}^{-\\mathrm{i} S_{\\boldsymbol{k}}^{-1} H_{\\boldsymbol{k}}(t_2)\\frac{\\Delta t}{2}} \\mathrm{e}^{-\\mathrm{i} S_{\\boldsymbol{k}}^{-1} H_{\\boldsymbol{k}}(t_1)\\frac{\\Delta t}{2}}$.\n  - 3: Crank-Nicolson, based on solving linear equation.",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "td_stype": {
    "availability": "",
    "default": "0",
    "description": "Type of electric field in the space domain, i.e. the gauge of the electric field.\n  - 0: Length gauge.\n  - 1: Velocity gauge.\n  - 2: Hybrid gauge. See [*J. Chem. Theory Comput.* 2025, 21, 3335−3341](https://pubs.acs.org/doi/10.1021/acs.jctc.5c00111) for more information.",
    "enum": [
      "0",
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "td_tend": {
    "availability": "",
    "default": "1000",
    "description": "The final time step when the time-dependent electric field is deactivated. The field remains active between `td_tstart` and `td_tend`.",
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "td_trape_amp": {
    "availability": "",
    "default": "2.74",
    "description": "Amplitude $A$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "V/Å"
  },
  "td_trape_freq": {
    "availability": "",
    "default": "1.60",
    "description": "Frequency $f$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "1/fs"
  },
  "td_trape_phase": {
    "availability": "",
    "default": "0.0",
    "description": "Phase $\\varphi$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_trape_t1": {
    "availability": "",
    "default": "1875",
    "description": "Step number of the time interval $t_1$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_trape_t2": {
    "availability": "",
    "default": "5625",
    "description": "Step number of the time interval $t_2$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_trape_t3": {
    "availability": "",
    "default": "7500",
    "description": "Step number of the time interval $t_3$ of the trapezoid type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_trigo_amp": {
    "availability": "",
    "default": "2.74",
    "description": "Amplitude $A$ of the trigonometric type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "V/Å"
  },
  "td_trigo_freq1": {
    "availability": "",
    "default": "1.164656",
    "description": "Frequency $f_1$ of the trigonometric type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "1/fs"
  },
  "td_trigo_freq2": {
    "availability": "",
    "default": "0.029116",
    "description": "Frequency $f_2$ of the trigonometric type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": "1/fs"
  },
  "td_trigo_phase1": {
    "availability": "",
    "default": "0.0",
    "description": "Phase $\\varphi_1$ of the trigonometric type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_trigo_phase2": {
    "availability": "",
    "default": "0.0",
    "description": "Phase $\\varphi_2$ of the trigonometric type electric field.",
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_tstart": {
    "availability": "",
    "default": "1",
    "description": "The initial time step when the time-dependent electric field is activated.",
    "mdType": "Integer",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "integer",
    "unit": ""
  },
  "td_ttype": {
    "availability": "",
    "default": "0",
    "description": "Type of electric field in the time domain.\n  - 0: Gaussian type function:\n\n  $$\n    E(t) = A \\cos\\left[2\\pi f(t-t_0)+\\varphi\\right]\\exp\\left[-\\frac{(t-t_0)^2}{2\\sigma^2}\\right]\n  $$\n\n  - 1: Trapezoid function:\n\n  $$\n    E(t) =\n    \\begin{cases}\n        A \\cos(2\\pi f t + \\varphi) \\cdot \\dfrac{t}{t_1}, & t < t_1 \\\\\n        A \\cos(2\\pi f t + \\varphi), & t_1 \\leqslant t \\leqslant t_2 \\\\\n        A \\cos(2\\pi f t + \\varphi) \\left(1 - \\dfrac{t - t_2}{t_3 - t_2}\\right), & t_2 < t < t_3 \\\\\n        0, & t \\geqslant t_3\n    \\end{cases}\n  $$\n\n  - 2: Trigonometric function:\n\n  $$\n    E(t) = A \\cos(2\\pi f_1 t + \\varphi_1) \\sin^2(2\\pi f_2 t + \\varphi_2)\n  $$\n\n  - 3: Heaviside step function:\n\n  $$\n    E(t) =\n    \\begin{cases}\n        A, & t < t_0 \\\\\n        0, & t \\geqslant t_0\n    \\end{cases}\n  $$",
    "enum": [
      "0",
      "1",
      "2",
      "3"
    ],
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "td_vext": {
    "availability": "",
    "default": "False",
    "description": "- True: Add a laser-material interaction (external electric field).\n  - False: No external electric field.",
    "mdType": "Boolean",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "boolean",
    "unit": ""
  },
  "td_vext_dire": {
    "availability": "",
    "default": "1\n\n  > Note: The axes refer to the absolute Cartesian coordinate system, which is independent of lattice vectors or reciprocal space definitions.​ This is different from [`efield_dir`](#efield_dir), which is used in ground-state KSDFT.",
    "description": "Specifies the direction(s) of the external electric field when `td_vext` is enabled. For example, `td_vext_dire 1 2` indicates that external electric fields are applied to both the x and y directions simultaneously. Electric field parameters can also be written as strings. For example, `td_gauss_phase 0 1.5707963` indicates that the Gaussian type electric fields in the x and y directions have a phase delay of $\\pi/2$. See below for more electric field parameters.\n  - 1: The external field direction is along the x-axis.\n  - 2: The external field direction is along the y-axis.\n  - 3: The external field direction is along the z-axis.",
    "enum": [
      "1",
      "2",
      "3"
    ],
    "mdType": "String",
    "section": "RT-TDDFT: Real-Time Time-Dependent Density Functional Theory",
    "type": "string",
    "unit": ""
  },
  "test_force": {
    "availability": "",
    "default": "0",
    "description": "Specify whether to output the detailed components in forces.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "test_skip_ewald": {
    "availability": "",
    "default": "0",
    "description": "Specify whether to skip the calculation of the ewald energy.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "test_stress": {
    "availability": "",
    "default": "0",
    "description": "Specify whether to output the detailed components in stress.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "timer_enable_nvtx": {
    "availability": "",
    "default": "False",
    "description": "Controls whether NVTX profiling labels are emitted by the timer. This feature is only effective on CUDA platforms.\n\n  - True: Enable NVTX profiling labels in the timer.\n  - False: Disable NVTX profiling labels in the timer.",
    "mdType": "Boolean",
    "section": "System variables",
    "type": "boolean",
    "unit": ""
  },
  "towannier90": {
    "availability": "",
    "default": "0",
    "description": "Controls the generation of files for the Wannier90 code.\n  - 1: Generate files for the Wannier90 code.\n  - 0: Do not generate files for the Wannier90 code.",
    "enum": [
      "1",
      "0"
    ],
    "mdType": "Integer",
    "section": "Berry phase and wannier90 interface",
    "type": "integer",
    "unit": ""
  },
  "uramping": {
    "availability": "DFT+U calculations with `mixing_restart > 0`.",
    "default": "-1.0.",
    "description": "Once `uramping` > 0.15 eV. DFT+U calculations will start SCF with U = 0 eV, namely normal LDA/PBE calculations. Once SCF restarts when `drho<mixing_restart`, U value will increase by `uramping` eV. SCF will repeat above calcuations until U values reach target defined in `hubbard_u`. As for `uramping=1.0 eV`, the recommendations of `mixing_restart` is around `5e-4`.",
    "mdType": "Real",
    "section": "DFT+*U* correction",
    "type": "number",
    "unit": "eV"
  },
  "use_k_continuity": {
    "availability": "Used only for plane wave basis set.",
    "default": "false",
    "description": "Whether to use k-point continuity for initializing wave functions. When enabled, this strategy exploits the similarity between wavefunctions at neighboring k-points by propagating the wavefunction from a previously initialized k-point to a new k-point, significantly reducing the computational cost of the initial guess.\n\n  **Important constraints:**\n  - Must be used together with `diago_smooth_ethr = 1` for optimal performance\n\n  This feature is particularly useful for calculations with dense k-point sampling where the computational cost of wavefunction initialization becomes significant.",
    "mdType": "Boolean",
    "section": "Plane wave related variables",
    "type": "boolean",
    "unit": ""
  },
  "vdw_C6_file": {
    "availability": "`vdw_method` is set to `d2`",
    "default": "default",
    "description": "Specifies the name of the file containing $C_6$ parameters for each element when using the D2 method. If not set, ABACUS uses the default $C_6$ parameters (Jnm6/mol) stored in the [program](https://github.com/deepmodeling/abacus-develop/blob/develop/source/source_hamilt/module_vdw/vdwd2_parameters.cpp). To manually set the $C_6$ parameters, provide a file containing the parameters. An example is given by:\n\n  ```text\n  H  0.1\n  Si 9.0\n  ```\n\n  Namely, each line contains the element name and the corresponding $C_6$ parameter.",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_C6_unit": {
    "availability": "`vdw_C6_file` is not default",
    "default": "Jnm6/mol",
    "description": "Specifies the unit of the provided $C_6$ parameters in the D2 method. Available options are:\n  - `Jnm6/mol` (J·nm^6/mol)\n  - `eVA` (eV·Angstrom)",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_R0_file": {
    "availability": "`vdw_method` is set to `d2`",
    "default": "default",
    "description": "Specifies the name of the file containing $R_0$ parameters for each element when using the D2 method. If not set, ABACUS uses the default $R_0$ parameters (Angstrom) stored in the [program](https://github.com/deepmodeling/abacus-develop/blob/develop/source/source_hamilt/module_vdw/vdwd2_parameters.cpp). To manually set the $R_0$ parameters, provide a file containing the parameters. An example is given by:\n\n  ```text\n  Li 1.0\n  Cl 2.0\n  ```\n\n  Namely, each line contains the element name and the corresponding $R_0$ parameter.",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_R0_unit": {
    "availability": "`vdw_R0_file` is not default",
    "default": "A",
    "description": "Specifies the unit for the $R_0$ parameters in the D2 method when manually set by the user. Available options are:\n  - `A` (Angstrom)\n  - `Bohr`",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_a1": {
    "availability": "`vdw_method` is set to `d3_0` or `d3_bj`",
    "default": "",
    "description": "This damping function parameter is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the [webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the `dft_functional` keywords. User set value will overwrite the searched value.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": ""
  },
  "vdw_a2": {
    "availability": "`vdw_method` is set to `d3_0` or `d3_bj`",
    "default": "",
    "description": "This damping function parameter is only relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the [webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the `dft_functional` keywords. User set value will overwrite the searched value.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": ""
  },
  "vdw_abc": {
    "availability": "`vdw_method` is set to `d3_0` or `d3_bj`",
    "default": "False",
    "description": "Determines whether three-body terms are calculated for DFT-D3 methods.\n  - True: ABACUS will calculate the three-body term.\n  - False: The three-body term is not included.",
    "mdType": "Integer",
    "section": "vdW correction",
    "type": "integer",
    "unit": ""
  },
  "vdw_cn_thr": {
    "availability": "`vdw_method` is set to `d3_0` or `d3_bj`",
    "default": "40",
    "description": "The cutoff radius when calculating coordination numbers.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": "defined by `vdw_cn_thr_unit` (default: `Bohr`)"
  },
  "vdw_cn_thr_unit": {
    "availability": "",
    "default": "Bohr",
    "description": "Unit of the coordination number cutoff (`vdw_cn_thr`). Available options are:\n  - `A`(Angstrom)\n  - `Bohr`",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_cutoff_period": {
    "availability": "`vdw_cutoff_type` is set to `period`",
    "default": "3 3 3",
    "description": "The three integers supplied here explicitly specify the extent of the supercell in the directions of the three basis lattice vectors.",
    "mdType": "Integer Integer Integer",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_cutoff_radius": {
    "availability": "`vdw_cutoff_type` is set to `radius`",
    "default": "- 56.6918 if `vdw_method` is set to `d2`\n  - 95 if `vdw_method` is set to `d3_0` or `d3_bj`",
    "dependencies": {
      "vdw_cutoff_type": "radius"
    },
    "description": "Defines the radius of the cutoff sphere when `vdw_cutoff_type` is set to `radius`. The default values depend on the chosen `vdw_method`.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": "defined by `vdw_radius_unit` (default `Bohr`)"
  },
  "vdw_cutoff_type": {
    "availability": "",
    "default": "radius",
    "description": "Determines the method used for specifying the cutoff radius in periodic systems when applying Van der Waals correction. Available options are:\n  - `radius`: The supercell is selected within a sphere centered at the origin with a radius defined by `vdw_cutoff_radius`.\n  - `period`: The extent of the supercell is explicitly specified using the `vdw_cutoff_period` keyword.",
    "enum": [
      "radius",
      "period"
    ],
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_d": {
    "availability": "`vdw_method` is set to `d2`",
    "default": "20",
    "description": "Controls the damping rate of the damping function in the DFT-D2 method.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": ""
  },
  "vdw_method": {
    "availability": "",
    "default": "none",
    "description": "Specifies the method used for Van der Waals (VdW) correction. Available options are:\n  - `d2`: [Grimme's D2](https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20495) dispersion correction method\n  - `d3_0`: [Grimme's DFT-D3(0)](https://aip.scitation.org/doi/10.1063/1.3382344) dispersion correction method (zero-damping)\n  - `d3_bj`: [Grimme's DFTD3(BJ)](https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21759) dispersion correction method (BJ-damping)\n  - `none`: no vdW correction",
    "enum": [
      "d2",
      "d3_0",
      "d3_bj",
      "none"
    ],
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_radius_unit": {
    "availability": "`vdw_cutoff_type` is set to `radius`",
    "default": "Bohr",
    "description": "Specify the unit of `vdw_cutoff_radius`. Available options are:\n  - `A`(Angstrom)\n  - `Bohr`",
    "mdType": "String",
    "section": "vdW correction",
    "type": "string",
    "unit": ""
  },
  "vdw_s6": {
    "availability": "`vdw_method` is set to `d2`, `d3_0`, or `d3_bj`",
    "default": "- 0.75: if `vdw_method` is set to `d2`",
    "description": "This scale factor is used to optimize the interaction energy deviations in van der Waals (vdW) corrected calculations. The recommended values of this parameter are dependent on the chosen vdW correction method and the DFT functional being used. For DFT-D2, the recommended values are 0.75 (PBE), 1.2 (BLYP), 1.05 (B-P86), 1.0 (TPSS), and 1.05 (B3LYP). If not set, will use values of PBE functional. For DFT-D3, recommended values with different DFT functionals can be found on the [here](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the `dft_functional` keywords. User set value will overwrite the searched value.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": ""
  },
  "vdw_s8": {
    "availability": "`vdw_method` is set to `d3_0` or `d3_bj`",
    "default": "",
    "description": "This scale factor is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the [webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the `dft_functional` keywords. User set value will overwrite the searched value.",
    "mdType": "Real",
    "section": "vdW correction",
    "type": "number",
    "unit": ""
  },
  "vh_in_h": {
    "availability": "",
    "default": "1",
    "description": "Specify whether to include Hartree potential term in obtaining the Hamiltonian matrix.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "vion_in_h": {
    "availability": "",
    "default": "1",
    "description": "Specify whether to include local ionic potential term in obtaining the Hamiltonian matrix.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "vl_in_h": {
    "availability": "",
    "default": "1",
    "description": "Specify whether to include local pseudopotential term in obtaining the Hamiltonian matrix.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "vnl_in_h": {
    "availability": "",
    "default": "1",
    "description": "Specify whether to include non-local pseudopotential term in obtaining the Hamiltonian matrix.\n  - 0: No.\n  - 1: Yes.",
    "enum": [
      "0",
      "1"
    ],
    "mdType": "Boolean",
    "section": "Variables useful for debugging",
    "type": "boolean",
    "unit": ""
  },
  "wannier_method": {
    "availability": "",
    "default": "1",
    "description": "Only available on LCAO basis, using different methods to generate \"\\*.mmn\" file and \"\\*.amn\" file.\n  - 1: Calculated using the `lcao_in_pw` method, the calculation accuracy can be improved by increasing `ecutwfc` to maintain consistency with the pw basis set results.\n  - 2: The overlap between atomic orbitals is calculated using grid integration. The radial grid points are generated using the Gauss-Legendre method, while the spherical grid points are generated using the Lebedev-Laikov method.",
    "enum": [
      "1",
      "2"
    ],
    "mdType": "Integer",
    "section": "Berry phase and wannier90 interface",
    "type": "integer",
    "unit": ""
  },
  "wannier_spin": {
    "availability": "",
    "default": "`up`",
    "dependencies": {
      "nspin": 2
    },
    "description": "The spin direction for the Wannier function calculation when nspin is set to 2\n  - `up`: Calculate spin up for the Wannier function.\n  - `down`: Calculate spin down for the Wannier function.",
    "enum": [
      "up",
      "down"
    ],
    "mdType": "String",
    "section": "Berry phase and wannier90 interface",
    "type": "string",
    "unit": ""
  },
  "xc_corr_ext": {
    "availability": "",
    "default": "130 0.06672455060314922 0.031090690869654895034 1.0",
    "description": "Customized parameterization on the correlation part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to [LibXC](https://libxc.gitlab.io/functionals/). For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: [gga_c_pbe.c](https://gitlab.com/libxc/libxc/-/blob/7.0.0/src/gga_c_pbe.c).",
    "mdType": "Integer Real ...",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "xc_exch_ext": {
    "availability": "",
    "default": "101 0.8040 0.2195149727645171",
    "description": "Customized parameterization on the exchange part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to [LibXC](https://libxc.gitlab.io/functionals/). For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC: [gga_x_pbe.c](https://gitlab.com/libxc/libxc/-/blob/7.0.0/src/gga_x_pbe.c).",
    "mdType": "Integer Real ...",
    "section": "Electronic structure",
    "type": "string",
    "unit": ""
  },
  "xc_kernel (Under Development Feature)": {
    "availability": "",
    "default": "LDA",
    "description": "The exchange-correlation kernel used in the calculation.\nCurrently supported: `RPA`, `LDA`, `PBE`, `HSE`, `HF`.",
    "mdType": "String",
    "section": "Linear Response TDDFT (Under Development Feature)",
    "type": "string",
    "unit": ""
  },
  "xc_temperature": {
    "availability": "",
    "default": "0.0",
    "description": "Specifies temperature when using temperature-dependent XC functionals (KSDT and so on).",
    "mdType": "Real",
    "section": "Electronic structure",
    "type": "number",
    "unit": "Ry"
  },
  "yukawa_lambda": {
    "availability": "DFT+U with `yukawa_potential` = True.",
    "default": "Calculated on the fly.",
    "description": "The screen length of Yukawa potential. If left to default, the screen length will be calculated as an average of the entire system. It's better to stick to the default setting unless there is a very good reason.",
    "mdType": "Real",
    "section": "DFT+*U* correction",
    "type": "number",
    "unit": ""
  },
  "yukawa_potential": {
    "availability": "",
    "default": "False",
    "description": "Determines whether to use the local screen Coulomb potential method to calculate the values of U and J.\n  - True: `hubbard_u` does not need to be specified.\n  - False: `hubbard_u` does need to be specified.",
    "mdType": "Boolean",
    "section": "DFT+*U* correction",
    "type": "boolean",
    "unit": ""
  },
  "zgate": {
    "availability": "",
    "default": "0.5",
    "description": "Position of the charged plate in the unit cell",
    "mdType": "Real",
    "section": "Gate field (compensating charge)",
    "type": "number",
    "unit": "Unit cell size"
  }
}